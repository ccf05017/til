## 3. 클래스와 인터페이스
- 자바 추상화의 핵심 근간
- 그만큼 지원하는 기능도 많다.

### Item 15. 클래스와 멤버의 접근 권한을 최소화하라
#### 왜?
- 소프트웨어의 설계의 근간이 되는 원리는 캡슐화다.
- 이를 위해 컴포넌트 간에는 API로만 통신하고 서로의 구현으로부터 자유로워진다.
- 이 캡슐화가 잘 된 것이 곧 좋은 설계이고, 이 캡슐화를 지원하는 기본 도구가 `접근 권한`이다.
- 그러니 접근 권한을 잘 관리해서 최대한 캡슐화를 잘 해라

#### 기본 원칙
- 모든 클래스와 멤버의 접근성을 가능한 좁혀라
- 즉, 일단 다 private을 발라놓고 정 안될때 package-private -> public 순으로 공개 범위를 넓혀라

#### 클래스 레벨의 접근 권한
- 톱레벨 클래스, 인터페이스가 public으로 선언된다는 건 영원히 하위 호환을 관리하겠다는 의미다.
- 그러니 꼭 공개해야 될 기능 외에는 다 package-private으로 숨겨라
- 한 클래스에서만 사용되는 package-private 톱레벨 클래스나 인터페이스는 사용하는 클래스의 private static으로 중첩시켜라(Item24참조)

#### 멤버 레벨의 접근 권한
- 멤버의 정의: 클래스의 필드, 메서드, 중첩 클래스, 중첩 인터페이스
- package-private, protected의 가장 큰 차이점은 protected 접근자 멤버의 경우 하위 클래스에서도 접근 가능하다.
- 즉, public 클래스의 protected 멤버는 공개 API나 다름 없다. -> 영원히 관리하며 고통받아야 한다.
    - 상속이나 기타 방안을 통해 외부 여기저기서 접근 가능하기 때문이다.
- 이런 사태를 피하고 싶으면 클래스 레벨 접근 권한과 마찬가지로 접근 범위를 최대한 좁혀라
- 다만, 제약 사항이 한가지 있다. 상위 클래스 메서드를 재정의할 때는 해당 멤버의 접근 권한을 상위 클래스에서보다 좁게 설정할 수 없다.
    - 즉, 인터페이스를 구현하는 경우에는 모든 인터페이스 구현 메서드들을 public으로 지정해야 한다.
- 테스트를 위해 범위를 넓히는 것은 package-private 까지만이다.
    - 그 이상 넓히는 건 설계를 잘못한 거다. 다시 생각해라.
- public 클래스의 인스턴스 필드는 모조리 private 바르고 시작해라
    - 가변 객체를 참조하거나 final이 아닌 인스턴스 필드가 public이면 불변식을 유지시킬 방법이 없다.
    - 스레드 안전하게 만들기가 굉장히 힘든 구조다.
    - 정적 필드라고 예외가 아니다 일단 다 private으로 만들어라
    - 딱 한가지 예외는 추상화된 의미가 있는 상수다. 얘만 public static final이 허용된다. (관례를 따라 구현하라)
- 위의 내용에서 특히 유의해아 할 사항은 `길이가 0이 아닌 배열은 모두 변경 가능하다`는 점이다.
    - 이런 게 공개되면 난리난다.
        ```java
        public static final Thing[] VALUES = {...};
        ```
    - 가능한 일급 컬렉션으로 감싸서 불변식을 유지하는 게 좋다.
    - 그게 아니라면 아래와 같은 방법들도 있다.
        ```java
        // public 배열을 private으로 만들고 public 불변 리스트를 추가한다.
        // 외부 공개용 불변 컬렉션을 만들어서 따로 제공하란 얘기
        private static final Thing[] PIRVATE_VALUES = {...};
        public static final List<Thing> VALUES =
            Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
        
        // 배열을 private으로 만들고 public 메서드에서는 복사본을 전달한다.
        private static final Thing[] PRIVATE_VALUES = {...};
        public static final Thing[] values() {
            return PRIVATE_VALUES.clone();
        }
        ```

#### 그 외 방안
- 자바 9부터는 모듈 개념이 추가됐다.
- 근데 가능한 쓰지 마라(사실 이해도 안됨..)

### Item 16. public 클래스에서는 public 필드를 사용하지 말아라
#### 왜?
- 캡슐화의 이점이 완전히 사라진다.
- 또한 내부 구현 수정은 API 수정으로 이어지기 때문에 호환성 보장이 굉장히 어렵다.
- 해당 필드에 대한 불변식을 보장할 수도 없다.

#### 그럼 어떻게?
- 늘 하던대로 public 클래스의 필드는 모조리 private으로 박아넣어라
- 그러고 getter, setter를 사용해라
    - 물론 DDD에서는 이것도 아니고 비즈니스적 의미가 있는 개별 메소드로 사용해라
- 필드가 불변이면 노출해도 되지 않을까? => 안된다! 그래도 여전히 안된다!
    - 불변 필드는 불변식을 보장할 수는 있다.
    - 하지만 여전히 필드를 읽을 때 부수 작업을 수행할 수 ㅇ벗다.
    - 또한 표현 방식으 바꿀 때마다 여전히 API가 변경된다.
    
#### 예외
- package-private 클래스, private 중첩 클래스는 필드를 pulbic으로 두는 게 나을 수 있다.
- 어차피 접근하는 클라이언트 코드들도 패키지 내부 코드들이다.
- 굳이 getter, setter 떡칠해서 복잡하게 만드는 것보다 접근하는 대상이 제한된 상태에서는 public으로 노출하는 편이 나을 수도 있다.

### Item 17. 변경 가능성을 최소화하라
- `불변 클래스`가 정상적인 경우다.
    - 우린 가변 클래스부터 배우지만 가변 클래스가 오히려 변종이다.
#### 왜?
- 불변은 설계, 구현, 사용 모두 가변 클래스보다 쉽고 안전하다.
- 근본적으로 thread safe 하기 때문에 동시성을 다룰 때 사용해도 괜찮다.

#### 조건이 무엇인가?
- 객체의 공개 필드에 대한 변경 방법을 아예 제공하지 않는다.
- 상속을 금지시킨다.
    - 클래스를 final로 선언하면 된다.
    - 혹은 public 정적 팩터리 메소드를 제공한다.
        - 이 방법이 final 클래스보다 훨씬 유연하고 필요 시 캐싱 기능을 추가하기가 용이하다.
- 필드에 final, private을 도배 하자
    - 물론 일부 불가능한 상황에서는(JPA 같은) `변경 못하게 한다`의 일환으로 세터만 없애버리자
- 자신 외에는 내부의 가변 컴포넌트에 접근도 못하게 막아라

#### 장점
- 불변 객체 구현은 함수형 프로그래밍 기법을 사용한다.
    - 함수형 프로그래밍: 피연산자에 함수를 적용해 결과를 반환하지만, 피연산자 자체는 실행 뒤에도 그대로인 기법
- 불변 객체는 원자성을 갖는다.
    - 한번 생성되면 죽을때까지 올바른 객체다. 믿을 수 있다.
- 그렇기 때문에 안심하고 공유할 수 있고, 방어적 복사도 필요없다.
- 불변 객체끼리는 내부 데이터를 공유할 수 있다.
    - 이 부분은 무슨 얘긴지 잘 모르겠다...
- 불변식 유지가 용이하다.
- 실패 원자성을 제공한다.
    - 실패 원자성: 메서드 예외가 발생한 후에도 해당 객체는 여전히 유효한 상태이다.

#### 단점
- 값이 다르다면 반드시 독립된 객체로 만들어야 한다.
- 약간의 성능저하를 일으킬 수 있다.
    - 하지만 JVM 공식 문서에 이로 인한 성능저하보다 니가 만드는 가변 객체가 더 위험하다고 나와 있다.

#### 해결책
- 예상되는 다단계 연산을 기본 기능으로 제공한다.
    - BigInteger가 좋은 예시다.
- 혹은 package-private 가변 동반 클래스를 제공한다.
    - String, StringBuilder가 대표적인 예시다.

#### 팁
- BigInteger는 조심해라 불변 객체지만 내부 객체에 불변이 아닌 부분이 있다.
    - 사용 시 불변이 확실한지 확인하고 사용해라
- 불변 객체 내부 필드 중 가변 객체를 참조하는 필드가 있다면 직렬화 시 주의가 필요하다.
    - Item 88에서 추가로 나올 것

### Item 18. 상속보다는 컴포지션을 사용하자
#### 왜?
- 상속은 캡슐화를 해친다
    - 물론 내가 다 제어한다면 상속을 도배해도 문제 없다. 상위 클래스도 내가 제어하니까
    - 당연히 상위 클래스 수정 한방에 코드 전체가 틀어지는 지옥은 각오해야 한다.
- 상속을 통해 클래스를 구현하면 상위 클래스의 구현 세부사항을 어느정도 알고 있어야 한다.
    - 이 때문에 코드 종속성이 매우 높아진다.
- 특히, 상위 클래스의 성능상 문제가 있다면 상속받은 하위 클래스는 죽을 때까지 그 문제를 같이 안고 간다.
- 결론은 현실에서 상속 받은 것과 마찬가지로 편하게 코드를 재사용할 수 있지만, 빚(단점)도 다 물려받는다.

#### 컴포지션은 어떻게 쓰나?
- 간단하다. 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 만든다.
    - 스프링을 쓰면 자연스럽게 이렇게 만들어진다.
- 또한 전달 방식과 컴포지션을 결합시켜서 재사용성이 높은 유연한 코드를 만들 수 있다.
    - 데코레이션 패턴의 일종이라 한다.(이펙티브자바 저자의 주장)
    - 상속받고 싶은 클래스를 Wrapper 클래스에서 인스턴스로 참조하게 만든다.
    - Wrapper 클래스에서 원하는 기능을 수행하고 결과를 반환하게 만든다.
    - 실제 구현할 대상이 되는 코드에서 Wrapper 클래스를 상속받는다.
    - 자바지기님의 람다 예외 처리 예시가 이와 유사하다(https://www.slipp.net/questions/572)
    
#### 컴포지션 + Wrapper의 단점
- 귀찮다
    - 쓸 코드가 좀 된다.
    - 그래도 상속 남발하다가 삽 푸는 것보다는 훨씬 덜 귀찮다.
- 콜백 프레임워크에서 쓰기 어렵다.
    - 콜백 프레임워크는 자기 자신의 참조를 다른 객체에게 넘겨줘야 한다.
    - 문제는 내부 객체가 Wrapper 클래스의 존재를 모르기 때문에 자기 자신의 참조를 넘긴다.
    - 이 때문에 Wrapper 클래스가 제대로 동작하지 않을 수 있다.
    - 좀 귀찮아도 Wrapper 없이 컴포지션 쓰면 된다.
    
#### 결론
- 상속은 진짜 아무리 생각해도 is-a 관계가 성립할 때만 쓰자
    - 심지어 자바 자체에도 이걸 안지킨 케이스가 있다.
    - Stack은 Vector가 아닌데 Vector를 확장해서 구현했다거나 이런 것들
- 불안하다면 상속 쓰지 말고 컴포지션을 도배하자.

### Item 19. 상속을 사용할 땐 설계화하고 문서화해라. 아니면 쓰지 말아라
#### 왜?
- Item 18의 사례에서 볼 수 있듯이 상속으로 확장할 경우 하위 클래스가 원하지 않는 동작으로 버그가 발생할 수 있다.
- 또한, 문서를 통해 상속 시 유의사항이 없다면 하위 클래스에서 상위 클래스에 대응할 방안이 아예 없다.

#### 문서화?
- 상속용으로 설계된 클래스는 재정의 할 수 있는 메서드들을 내부적으로 어떻게 쓰는지 남겨야 한다.
- `public, protected 메서드 중 final이 아닌 모든 메서드의 내부 사용을 문서화`하란 얘기다.
- 결국 '무엇을 하는지' 설명하는 문서가 아니라 '어떻게 하는지' 설명하는 안좋은 API 문서를 남기게 된다.
- 상속이 캡슐화를 해치기 때문에 어쩔 수 없이 이 부분을 감수해야 한다.
- 또한 상속을 위한 문서는 인스턴스만 사용하려는 사용자에게 완전히 쓸모 없는 군더더기다.
    - 아직까지 상속용 문서와 일반 문서를 구분할 도구나 방안이 없다.

#### Hook을 제공하자
- 클래스의 내부 동작에서 개선이 필요한 부분을 적당히 선별해서 Hook을 만들어주자
- 하위 클래스는 이 Hook을 통해 상위 클래스에 간섭하고 원하는 기능을 추가할 수 있다.
- 어떤 훅을 구현할지는 어떻게 정할까?
    - 방법은 하나다. `직접 하위 클래스를 만들어` 봐야 한다. 유일한 방법이다.

#### 굳이 상속을 사용할 때의 주의사항
- 절대로 override가 가능한 메서드를 상속용 클래스의 생성자에서 호출해서는 안된다.
- 간접적으로도 안된다!!!
- 생성자는 상위 슈퍼 클래스의 생성자부터 실행 되는데, 이 안에 override 가능한 메서드가 있으면,
    - 하위 인스턴스 생성 -> 상위 슈퍼 클래스 생성자 실행 -> 생성자 안의 `override 된 하위 클래스의 메서드 실행` -> 초기화가 아직 안된 변수 접근
    - => 멸망
- private, final, static 메서드는 재정의가 불가능하니까 써도 상관 없다.
- Cloneable, Serializable 인터페이스가 구현된 클래스는 가능한 상속하지 말아라
    - 생성자 때와 같은 제약사항을 지니고, 하위 클래스에게 아주아주아주 번거로운 작업을 강요하게 된다.
    
#### 상속용이 아닌 클래스는 상속을 아예 금지시켜라
- 최고의 해결책.
- 가장 간단한 건 클래스를 final로 선언하는 것
- final 선언이 불가능한 상황에서는 모든 생성자를 private이나 package-private으로 선언하자.
    - 그리고 사용을 위해 정적 팩토리를 하나 추가해주자. 여기서는 마음대로 override 메서드를 사용해도 된다.
- 상속이 필요하다면 상속 클래스의 표준 인터페이스를 구현하고 표준 인터페이스를 따르도록 하자.
- 그래도 그래도 진짜 반드시 꼭 상속이 필요하다면,
    - 기게적으로 private 메서드들을 찍어내서 상속용 클래스 내부에서 private 메서드끼리만 연결되게 하자.
    - override 가능한 메서드는 절대 클래스 내부에서 재사용하지 말고, 문서에도 명시하자.
