## 1. 모든 객체의 공통 메서드
- Object 구체 클래스가 모든 클래스에게 상속된다.
- 이 때문에 final이 아닌 메서드들(equals, hashCode, toString, clone 등)은 규약에 맞춰 재정의 해야한다.
- 안 그러면 오작동 할 수 있다.

### Item 10. equals는 일반 규약을 지켜서 재정의해라
#### 1. 개요
- 아예 재정의 안하는 걸 추천한다.
- 특히나 아래의 경우 중 한가지라도 속한다면 '절대 대정의하지 말아라'
    - 각 인스턴스가 본질적으로 고유하다. (동작을 표현하는 객체들)
    - '논리적으로 같은가'를 비교할 일이 절대 없다.
    - 상위 클래스에서 재정의한 equals가 하위 클래스에 딱 들어맞는다.
    - 클래스가 private, protected 접근자로 선언되어 있다.
    - equals 메서드는 때려죽여도 쓸 일이 없다.
- 위의 경우를 제외하면 아마도 DDD 전술 패턴의 VO를 구현할 때 equals 재정의가 필요할 것이다.
- 단, 그 중에서도 싱글톤과 enum은 재정의 할 필요가 없다. (비교 대상이 나타나지도 않을 것이다!)

#### 2. equal 재정의를 위한 일반 규약(반드시 지켜야 함)
- equals 메서드는 '동치관계'를 구현하며 아래 조건을 반드시 준수해야 한다.
    - 반사성: 객체는 자기 자신과 같아야 한다.(x.equals(x) = true)
    - 대칭성: 서로에 대한 동치 여부에 똑같이 답해야 한다(x.equals(y) = y.equals(x))
    - 추이성: 삼단논법을 통한 추론이 가능해야 한다.(x.equals(y) && y.equals(z) = x.equals(z))
    - 일관성: 한 번 같은편은 죽을 때까지 같은편, 한 번 원수는 죽을때까지 원수
    - null아님: x.equals(null) = false
    
##### 2.1 반사성
- 객체가 자기 자신과 같지 않게 만들어야 깨진다.
- 사실 깨기가 더 어렵다..

##### 2.2 대칭성
- 이 규약을 어기면 객체를 사용하는 다른 객체들의 반응을 예측할 수 없게 된다.
- 너무 과도하게 다른 객체와의 비교를 구현하려 할 때 깰 경우가 많다.
- 나랑 같은 타입일 때만 동등 비교하도록 구현하면 피할 수 있다.

##### 2.3 추이성
- 상속을 사용할 때 많이 실수하게 된다.
- 상위 클래스에 없는 새로운 필드를 하위 클래스에 추가하려다가 발생한다.
- 이걸 해결할 방법은 없다.
- 추상 클래스를 상속받거나 컴포지션을 사용해라. 그러면 자연스럽게 해결된다.

##### 2.4 일관성
- 불편 클래스의 경우 자연스럽게 지켜지기 때문에 큰 문제 없다.
- 가변 객체의 경우 equals 메서드 실행 중 신뢰할 수 없는 자원이 절대 끼어들어서는 안된다!!
- 자바의 URL 객체가 이런 걸 잘못 구현한 대표 사례다.

##### 2.5 null 아님
- 실수로 nullPointer 예외가 발생하는 것까지도 허용하지 않는다.
- 반드시 null 확인 절차를 넣어줘라.(더럽게 귀찮다. 코틀린은 안해도 된다.)
- 다만 명시적으로 구현하기 보다 equals 내에 묵시적으로 구현해라
```java
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof NotNullExample))   // 묵시적인 null 확인
        return false;
    return false;
}
```

#### 3. 그러니 이런 순서로 구현해라
- == 연산자를 통해 입력이 자기 자신의 참조인지 확인해라
- instanceof 연산자로 입력이 올바른 타입인지 확인해라
- 입력을 올바른 타입으로 형변환 시켜라
- 입력 객체와 자기 자신의 대응되는 '핵심 필드'들이 '모두' 일치하는지 확인해라

#### 4. 기본 타입 비교는?
- 기본 타입은 == 연산자로 비교해라(float, double 제외)
- float, double은 compare 메서드를 이용해라(소수점 계산 때문)

#### 5. 참고 사항
- 가끔 null도 정상 값으로 취급하는 참조 타입 필드가 있다. 이 경우 NullPointer 예외 발생에 유의하자
- 아주 복잡한 필드를 가진 경우 표준형을 저장해두고 표준형끼리 비교하면 효율적이다.

#### 6. 주의사항
- equals를 재정의 하면 버릇처럼 hashCode도 재정의해라
- 너무 복잡하게 접근하지 말아라 만악의. 근원이다.
- Object 외의 타입을 equals의 매개변수로 받지 말아라.

#### 7. 결론
- 나보다 인텔리제이가 더 똑똑하니까 인텔리제이 자동완성을 쓰자
- 인텔리제이가 없다면 구글의 AutoValue 프레임워크를 사용하자
- 물론 그래도 잘 만들어졌나 확인할 수 있고, 어떻게 만들어진가 알수 있을 정도로는 공부하쟈
