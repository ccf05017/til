## 3. 클래스와 인터페이스
- 자바 추상화의 핵심 근간
- 그만큼 지원하는 기능도 많다.

### Item 15. 클래스와 멤버의 접근 권한을 최소화하라
#### 왜?
- 소프트웨어의 설계의 근간이 되는 원리는 캡슐화다.
- 이를 위해 컴포넌트 간에는 API로만 통신하고 서로의 구현으로부터 자유로워진다.
- 이 캡슐화가 잘 된 것이 곧 좋은 설계이고, 이 캡슐화를 지원하는 기본 도구가 `접근 권한`이다.
- 그러니 접근 권한을 잘 관리해서 최대한 캡슐화를 잘 해라

#### 기본 원칙
- 모든 클래스와 멤버의 접근성을 가능한 좁혀라
- 즉, 일단 다 private을 발라놓고 정 안될때 package-private -> public 순으로 공개 범위를 넓혀라

#### 클래스 레벨의 접근 권한
- 톱레벨 클래스, 인터페이스가 public으로 선언된다는 건 영원히 하위 호환을 관리하겠다는 의미다.
- 그러니 꼭 공개해야 될 기능 외에는 다 package-private으로 숨겨라
- 한 클래스에서만 사용되는 package-private 톱레벨 클래스나 인터페이스는 사용하는 클래스의 private static으로 중첩시켜라(Item24참조)

#### 멤버 레벨의 접근 권한
- 멤버의 정의: 클래스의 필드, 메서드, 중첩 클래스, 중첩 인터페이스
- package-private, protected의 가장 큰 차이점은 protected 접근자 멤버의 경우 하위 클래스에서도 접근 가능하다.
- 즉, public 클래스의 protected 멤버는 공개 API나 다름 없다. -> 영원히 관리하며 고통받아야 한다.
    - 상속이나 기타 방안을 통해 외부 여기저기서 접근 가능하기 때문이다.
- 이런 사태를 피하고 싶으면 클래스 레벨 접근 권한과 마찬가지로 접근 범위를 최대한 좁혀라
- 다만, 제약 사항이 한가지 있다. 상위 클래스 메서드를 재정의할 때는 해당 멤버의 접근 권한을 상위 클래스에서보다 좁게 설정할 수 없다.
    - 즉, 인터페이스를 구현하는 경우에는 모든 인터페이스 구현 메서드들을 public으로 지정해야 한다.
- 테스트를 위해 범위를 넓히는 것은 package-private 까지만이다.
    - 그 이상 넓히는 건 설계를 잘못한 거다. 다시 생각해라.
- public 클래스의 인스턴스 필드는 모조리 private 바르고 시작해라
    - 가변 객체를 참조하거나 final이 아닌 인스턴스 필드가 public이면 불변식을 유지시킬 방법이 없다.
    - 스레드 안전하게 만들기가 굉장히 힘든 구조다.
    - 정적 필드라고 예외가 아니다 일단 다 private으로 만들어라
    - 딱 한가지 예외는 추상화된 의미가 있는 상수다. 얘만 public static final이 허용된다. (관례를 따라 구현하라)
- 위의 내용에서 특히 유의해아 할 사항은 `길이가 0이 아닌 배열은 모두 변경 가능하다`는 점이다.
    - 이런 게 공개되면 난리난다.
        ```java
        public static final Thing[] VALUES = {...};
        ```
    - 가능한 일급 컬렉션으로 감싸서 불변식을 유지하는 게 좋다.
    - 그게 아니라면 아래와 같은 방법들도 있다.
        ```java
        // public 배열을 private으로 만들고 public 불변 리스트를 추가한다.
        // 외부 공개용 불변 컬렉션을 만들어서 따로 제공하란 얘기
        private static final Thing[] PIRVATE_VALUES = {...};
        public static final List<Thing> VALUES =
            Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
        
        // 배열을 private으로 만들고 public 메서드에서는 복사본을 전달한다.
        private static final Thing[] PRIVATE_VALUES = {...};
        public static final Thing[] values() {
            return PRIVATE_VALUES.clone();
        }
        ```

#### 그 외 방안
- 자바 9부터는 모듈 개념이 추가됐다.
- 근데 가능한 쓰지 마라(사실 이해도 안됨..)

### Item 16. public 클래스에서는 public 필드를 사용하지 말아라
#### 왜?
- 캡슐화의 이점이 완전히 사라진다.
- 또한 내부 구현 수정은 API 수정으로 이어지기 때문에 호환성 보장이 굉장히 어렵다.
- 해당 필드에 대한 불변식을 보장할 수도 없다.

#### 그럼 어떻게?
- 늘 하던대로 public 클래스의 필드는 모조리 private으로 박아넣어라
- 그러고 getter, setter를 사용해라
    - 물론 DDD에서는 이것도 아니고 비즈니스적 의미가 있는 개별 메소드로 사용해라
- 필드가 불변이면 노출해도 되지 않을까? => 안된다! 그래도 여전히 안된다!
    - 불변 필드는 불변식을 보장할 수는 있다.
    - 하지만 여전히 필드를 읽을 때 부수 작업을 수행할 수 ㅇ벗다.
    - 또한 표현 방식으 바꿀 때마다 여전히 API가 변경된다.
    
#### 예외
- package-private 클래스, private 중첩 클래스는 필드를 pulbic으로 두는 게 나을 수 있다.
- 어차피 접근하는 클라이언트 코드들도 패키지 내부 코드들이다.
- 굳이 getter, setter 떡칠해서 복잡하게 만드는 것보다 접근하는 대상이 제한된 상태에서는 public으로 노출하는 편이 나을 수도 있다.

### Item 17. 변경 가능성을 최소화하라
- `불변 클래스`가 정상적인 경우다.
    - 우린 가변 클래스부터 배우지만 가변 클래스가 오히려 변종이다.
#### 왜?
- 불변은 설계, 구현, 사용 모두 가변 클래스보다 쉽고 안전하다.
- 근본적으로 thread safe 하기 때문에 동시성을 다룰 때 사용해도 괜찮다.

#### 조건이 무엇인가?
- 객체의 공개 필드에 대한 변경 방법을 아예 제공하지 않는다.
- 상속을 금지시킨다.
    - 클래스를 final로 선언하면 된다.
    - 혹은 public 정적 팩터리 메소드를 제공한다.
        - 이 방법이 final 클래스보다 훨씬 유연하고 필요 시 캐싱 기능을 추가하기가 용이하다.
- 필드에 final, private을 도배 하자
    - 물론 일부 불가능한 상황에서는(JPA 같은) `변경 못하게 한다`의 일환으로 세터만 없애버리자
- 자신 외에는 내부의 가변 컴포넌트에 접근도 못하게 막아라

#### 장점
- 불변 객체 구현은 함수형 프로그래밍 기법을 사용한다.
    - 함수형 프로그래밍: 피연산자에 함수를 적용해 결과를 반환하지만, 피연산자 자체는 실행 뒤에도 그대로인 기법
- 불변 객체는 원자성을 갖는다.
    - 한번 생성되면 죽을때까지 올바른 객체다. 믿을 수 있다.
- 그렇기 때문에 안심하고 공유할 수 있고, 방어적 복사도 필요없다.
- 불변 객체끼리는 내부 데이터를 공유할 수 있다.
    - 이 부분은 무슨 얘긴지 잘 모르겠다...
- 불변식 유지가 용이하다.
- 실패 원자성을 제공한다.
    - 실패 원자성: 메서드 예외가 발생한 후에도 해당 객체는 여전히 유효한 상태이다.

#### 단점
- 값이 다르다면 반드시 독립된 객체로 만들어야 한다.
- 약간의 성능저하를 일으킬 수 있다.
    - 하지만 JVM 공식 문서에 이로 인한 성능저하보다 니가 만드는 가변 객체가 더 위험하다고 나와 있다.

#### 해결책
- 예상되는 다단계 연산을 기본 기능으로 제공한다.
    - BigInteger가 좋은 예시다.
- 혹은 package-private 가변 동반 클래스를 제공한다.
    - String, StringBuilder가 대표적인 예시다.

#### 팁
- BigInteger는 조심해라 불변 객체지만 내부 객체에 불변이 아닌 부분이 있다.
    - 사용 시 불변이 확실한지 확인하고 사용해라
- 불변 객체 내부 필드 중 가변 객체를 참조하는 필드가 있다면 직렬화 시 주의가 필요하다.
    - Item 88에서 추가로 나올 것
