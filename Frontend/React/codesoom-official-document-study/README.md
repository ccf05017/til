# 리액트 공식문서 함께 읽기 스터디
- 20201026 ~ 20201120 매주 수요일 21:00~22:30
- 코드숨 그룹 주관 진행
- [공식문서](https://ko.reactjs.org/docs/hello-world.html)

## 1. 주요 개념
### 1.1. JSX
- 리액트의 관심사 분리: 컴포넌트
  - 별도의 파일에 마크업과 로직을 넣지 않는다.
  - 느슨하게 연결된 유닛으로 관심사 분리를 이룬다.
- 위와 같이 결정한 이유는 `렌더링 로직이 본질적으로 다른 UI로직과 연결된다`를 믿기 때문(?)
- [관련링크](https://www.youtube.com/watch?v=x7cQ3mrcKaY)
- 반드시 JSX로 리액트를 구현해야되는 것은 `아니다`
- JSX의 중괄호 안에는 `모든 자바스크립트 표현식`을 넣을 수 있다.
- JSX를 여러줄로 나눌 때는 괄호로 묶는 것이 좋다
  - 이게 없으면 자동 세미콜론이 붙으면서 오류가 발생할 수 있다.
- JSX도 표현식이다.
  - 컴파일이 끝나면 JSX도 `정규 자바스크립트 객체`로 인식된다.
  - 이 때문에 조건문, 반복문 사용이나 변수 할당, 인자 전달, 반환 등 모든 방면에 사용 가능하다.
- JSX의 속성 정의
  - HTML이 아닌 자바스크립트에 가깝기 때문에 카멜 케이스를 사용한다.
  - 속성에 문자열, 자바스크립트 표현식을 넣을 수 있다.
- JSX는 기본적으로 주입 공격을 방지한다.(XSS 방지)
  - 렌더링 전 모두 문자열로 변환되기 때문
- JSX의 객체 표현
  - 바벨에서 JSX를 React.createElement() 호출로 컴파일해준다.
  ```javascript
  const element = (
    <h1 className="hi">
      Hello, React!
    </h1>
  );

  const element2 = React.createElement(
    'h1',
    { className: 'hi' },
    'Hello, React!'
  );
  ```
  - CreateElement에 의해 컴파일된 자바스크립트 객체를 '리액트 엘리먼트'라 한다.
    - 이를 화면에 표시하려는 항목에 대한 설명으로 볼 수 있다.
    - 리액트가 DOM을 구성하고 최신으로 유지할 때 이 객체(엘리먼트)를 활용한다.
- 핵심질문: JSX를 표현식으로 취급하고 반복문, 조건문 등에 사용할 수 있는 이유는 JSX가 기본적으로 `자바스크립트 객체`이기 때문이다.

### 1.2. 엘리먼트
- 엘리먼트는 `리액트 앱의 가장 작은단위`
- 리액트 엘리먼트는 DOM 엘리먼트가 아니라 `일반 자바스크립트 객체`
- 컴포넌트 !== 엘리먼트
- 일반적으로 리액트는 `하나의 DOM 노드`에 `리액트 엘리먼트`를 렌더링해서 구현된다.
  - 기존 앱과 통합하는 과정에서는 독립된 루트 DOM이 여러개일 수 있다.
- 렌더링된 `리액트 DOM`은 `리액트 엘리먼트`와 일치하도록 DOM을 업데이트한다.
- 리액트 엘리먼트는 `불변객체`다.
  - 즉, 엘리먼트의 상태 변경은 없고 새로운 엘리먼트가 생성될 뿐이다.
  - 이 때문에 리액트의 상태에 따른 화면 변화는 `영화의 프레임`에 비유할 수 있다.
- 리액트의 렌더링은 `리액트 엘리먼트를 비교`하고 변경된 부분만 DOM에 업데이트한다.
- 핵심질문: 리액트 엘리먼트는 `불변` 자바스크립트 객체다.

### 1.3. 컴포넌트와 props
- 컴포넌트를 통해 UI를 재사용성이 높은 개별적인 여러 조각으로 나눌 수 있다.
- 컴포넌트는 개념적으로 자바스크립트 함수와 흡사하다.
  - props를 인자로 받고 화면에 어떻게 보일지 기술하는 `리액트 엘리먼트`를 반환한다.
  - props는 속성을 나타내는 데이터다.
  - props은 단일 `객체`다.
- 컴포넌트 이름은 무조건 `대문자`로 시작한다.
  - 소문자로 시작하면 DOM 태그로 처리한다.
- 컴포넌트는 가능한 작게 계속 쪼개자.
- props는 `읽기 전용`이다. 절대 props를 수정하지 말아라.
  - 즉, 모든 리액트 컴포넌트는 자신의 props를 다룰 때 `순수 함수`로 다뤄야 한다.
- 핵심질문: 컴포넌트는 `props`를 인자로 받고 화면에 어떻게 보일지 기술하는 `리액트 엘리먼트`를 반환하는 자바스크립트 `함수`다.

### 1.4. state와 생명주기
- 클래스 컴포넌트는 `생명주기 함수`로 렌더링 변경사항을 반영할 수 있다.
  - 클래스 컴포넌트 사용시 생성자에 `props`를 꼭 전달해야 한다.
- 리액트 컴포넌트가 DOM에 렌더링 되는 순간을 `마운팅`이라 한다. 
  - 관련 생명주기 함수: componentDidMount(), componentWillUnmount()
- state 관련 주의사항
  - 절대 직접 state를 수정하지 말 것.
    - setState를 사용해라
  - state 업데이트는 비동기적으로 일어날 수 있다.
    - `다음 state를 계산`할 때 `현재 state`에 의존하면 안된다.
    - 위의 현상을 피하려면 setState의 함수 인자로 콜백을 사용한다.
    ```javascript
    this.setState((state, props) => ({
      counter: state.counter + props.increment
    }));
    ```
  - setState 함수는 호출할 때 리액트에서 제공한 객체를 현재 state로 병합시킨다.
- 데이터는 아래로 흐른다
  - 부모 컴포넌는 props 형태로 자식 컴포넌트에게 상태를 전달할 수 있다.
- 핵심질문: state를 다룰 때 주의 사항 세가지는? -> 직접 수정 불가, 업데이트 비동기 가능성, 상태 병합

### 1.5. 이벤트 처리하기
- 일반적인 html 이벤트 핸들러와 유사하지만, 캐멀케이스를 사용한다.
- JSX를 사용할 경우 문자열이 아닌 `함수`로 이벤트를 전달한다.
- 리액트에서 이벤트 핸들러의 기본동작을 방지하려면 `명시적으로 preventDefault`가 있어야 한다.
```javascript
// <a href="#" onclick="console.log('The link was clicked.'); return false">
//   Click me
// </a>

function ActionLink() {
  function handleClick(e) {
    e.preventDefault();
    console.log('The link was clicked.');
  }

  return (
    <a href="#" onClick={handleClick}>
      Click me
    </a>
  );
}
```
- 리액트에서는 이벤트 핸들러의 인자로 `합성 이벤트 e`를 받는다.
  - [참고문서](https://www.w3.org/TR/DOM-Level-3-Events/)
- 클래스 컴포넌트로 이벤트 핸들러 정의 시 주의사항
  - 일반적으로 클래스 컴포넌트의 메서드로 구현한다.
  - 명시적인 this 바인딩에 주의해야 한다. (그놈의 클로저)
  - 클래스 메서드로 구현하지 않고 콜백을 이벤트 핸들러에 전달하면 매번 콜백이 재생성된다.
    - 일반적으로 문제는 없지만, 하위 컴포넌트에 props로 전달되면 그 컴포넌트들이 추가 렌더링을 수행할 수 있다.
    - 잘못하면 무한루프에 빠진다.
- 이벤트 핸들러에 인자를 전달할 수 있다.
  - 화살표 함수 사용 시
    ```javascript
    <button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
    ```
    - 명시적으로 `합성 이벤트 e`를 전달해야 한다.
  - Function.prototype.bind 사용 시
    ```javascript
    <button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>
    ```
    - 추가 인자로 `합성 이벤트 e`가 자동으로 전달된다.
- 핵심질문: 클래스 컴포넌트에서 이벤트 핸들러에 콜백을 사용하고 자식 컴포넌트에게 전달할 경우 `콜백이 매번 생성된다`

### 1.6. 조건부 렌더링
- 조건부 렌더링: 애플리케이션 상태에 따라 `일부 컴포넌트만 렌더링`하는 것
- 리엑트 엘리먼트는 표현식이기 때문에 자바스크립트의 조건문, 조건부 연산자를 모두 사용 가능하다.
```javascript
// 예시 1(조건문)
function Greeting({ loggedState }) {
  const isLoggedIn = loggedState;
  if (isLoggedIn) {
    return (
      <UserGreeting />
    );
  }
  return (
    <GuestGreeting />
  );
}

ReactDom.render(
  <Greeting loggedState={false} />,
  document.getElementById('root')
);

// 예시 2(논리 연산자)
function Mailbox({ unreadMessages }) {
  return (
    <div>
      {unreadMessages.length > 0 &&
        <h2>
          You have {unreadMessages.length} unread messages.
        </h2>
      }
    </div>
  )
}

ReactDOM.render(
  <Mailbox unreadMessages={[1, 2, 3]}>,
  document.getElementById('root')
);
```
- 엘리먼트를 변수로 취급해서 조건부 렌더링을 할 수도 있다.
- 컴포넌트가 렌더링 되는 걸 막고 싶다면 null을 반환하면 된다.
- 원하는 방법 쓰면 되지만, 가독성이 가장 좋은 방향을 팀원과 협의하고 결정하자.
- 핵심질문: 조건부 렌더링의 방법으로는 `조건문`, `조건부 연산자`, `논리 연산자` 등이 있다.

### 1.7. 리스트와 Key
- 리액트에서는 표현식에 리스트를 넣을 경우 그 요소를 개별로 렌더링해줄 수 있다.
```javascript
const numbers = [1, 2, 3, 4, 5];
const listNumbers = numbers.map((number) => <li>{number}</li>);

ReactDOM.render(
  <ul>{listNumbers}</ul>
  document.getElementId('root');
)
```
- 리액트에서 리스트를 렌더링할 때는 key를 필수적으로 넣어줘야 한다.
  - key가 있어야 리액트가 어떤 엘리먼트를 빼고 넣을지 계산할 수 있다.
  - key는 고유값을 사용해야 한다.
  - 일반적으로 데이터의 id를 key로 사용한다.
  - 최악의 경우에만 list의 index를 key로 사용해라.
  - key는 props로 전달되지 않는다. (필요하다면 별도 props로 지정해서 전달해라)
  - key는 형제 사이에만 고유하면 된다.
- 리스트를 꼭 변수에 넣지 않고 인라인 방식으로 넣어도 된다.
  - 하지만 늘 그렇듯 가독성을 고려해서 방식을 선택해라
- 핵심질문: 리액트에서 리스트를 렌더링할 때는 `key`를 무조건 지정해야 한다.

### 1.8. 폼
- HTML 폼은 자체적으로 내부 상태를 갖고 있다.
  - 이를 해결하기 위해 리액트의 다른 DOM 엘리먼트와는 좀 다르다.
  - HTML 동작을 그대로 써도 되지만, 보통 자바스크립트 함수로 폼을 처리하는 게 더 편하다.
  - 이 때 `제어 컴포넌트`라는 표준 기술을 사용하면 좋다.
- 리액트의 제어 컴포넌트
  - 리액트 상태를 `신뢰 가능한 단일 출처`로 만들어 사용자 입력과 리액트 상태를 결합한다.
  - 이를 통해 리액트에 의해 폼의 값을 제어 할 수 있고, 이를 `제어 컴포넌트`라 한다.
- testarea 태그
  - 일반적으로 HTML에서 textarea는 텍스트를 자식으로 정의한다.
    ```html
    <textarea>
      hi, thank you, bye
    </textarea>
    ```
  - 리액트에서는 textarea의 value 어트리뷰트를 사용한다. (다른 폼 요소와 동일하게)
- select 태그
  - 이 또한 일반적인 HTML과 살짝 다르다.
  - 리액트는 select 태그 또한 value 어트리뷰트를 사용한다.
- input, textarea, select 모두 value 어트리뷰트로 제어 컴포넌트를 구현한다.
- file input은 비제어 컴포넌트다.
- 다중 입력 제어하기
  - 여러개의 input 엘리먼트를 제어할 때, 각 엘리먼트에 name 어트리뷰트를 추가하고 관리할 수 있다.
  - 여러개의 input에 대한 상태를 한번에 관리할 수 있다.
- 핵심질문: 리액트에 의해 폼의 값을 제어하는 컴포넌트를 `제어 컴포넌트`라 한다.

## 2. Hook
### 2.1. Hook 소개
- Hook은 기존 리액트 코드와 100% 호환되며, 클래스 컴포넌트가 사라질 일은 없다.(당분간)
- 페이스북 팀이 Hook을 도입한 이유
  - 클래스 컴포넌트는 컴포넌트 사이에 상태와 관련된 로직을 재사용하기 어렵다.
    - 수많은 고차 컴포넌트와 props 중첩의 향연
  - 클래스 컴포넌트는 이해하기 어려운 수준으로 과도하게 복잡해질 때가 많다.
    - 생명 주기 위주로 관심사를 갖고 가면서 생기는 문제
    - Hook을 이용하면 로직에 기반을 둔 작은 함수로 컴포넌트를 나눌 수 있다.
    - 결론적으로 컴포넌트 재사용성이 너무 떨어진다.
  - 클래스는 사람과 기계 모두에게 혼동된다.
    - 자바스크립트 this 개념이 강제되고, 다른 언어와 매우 다른 이 개념은 사람 환장하게 만든다.
    - 기계도 헷갈린다. 최적화가 어렵다.
    - Hook은 클래스 없이 함수에 가까운 리액트 컴포넌트를 `명령형`으로 접근하도록 도와준다.
    - Hook은 `함수형 사고방식과 기법을 강요하지 않는다`. 오히려 `명령형`으로 대안을 찾도록 도와준다.
- 핵심질문: 리액트에서 Hook 컴포넌트와 Class 컴포넌트를 같이 사용할 수 없다 -> X

### 2.2. Hook 개요
- Hook은 `함수 컴포넌트`에서 `리액트 상태와 생명주기 기능을 연동`할 수 있게 해주는 `함수`다.
- Effect 훅
  - 클래스의 생명주기 함수들을 한군데서 관리할 수 있도록 도와준다.
  - 리액트에서의 Side Effect?
    - 데이터를 가져오거나 구독하는 것.
    - DOM을 직접 조작하는 것.
    - 즉, 다른 컴포넌트에 영향을 주거나, 렌더링 과정에서는 구현할 수 없는 것들.
  - render가 실행될 때마다 정의된 effect가 실행된다.
- 훅의 규칙
  - 최상위 레벨에서만 Hook을 호출해야 한다.
  - 리액트 함수 컴포넌트와 Custom 훅 안에서만 호출해야 한다.
- 커스텀 훅
  - 컴포넌트 간 `상태 관련 로직을 공유`하기 위해 사용한다.
  - 각각의 훅 호출은 `완전히 독립된 상태`를 갖는다.
  - 커스텀 훅은 기능보단 컨벤션에 가깝다.
  - `use 접두어`가 붙고, `안에서 다른 훅을 호출`한다면 커스텀 훅이라 할 수 있다.
- 핵심질문: Hook은 (함수 컴포넌트.)에서 (리액트 상태와 생명주기 기능을 연동)할 수 있게 해주는 (함수)다.

## 2.3. State 훅
- State 훅은 `state 변수`, `해당 변수를 갱싱한 수 있는 함수` 이 두가지를 반환한다.
- state는 컴포넌트가 렌더링 될 때 딱 한번만 생성된다.
- 함수 컴포넌트와 다르게 굳이 state를 this에 바인딩 시킬 필요가 없다.
- 클래스 컴포넌트와 가장 큰 차이점은 state 훅은 state 갱신 시 병합이 아니라 `대체`한다.
- 핵심질문: 클래스 컴포넌트의 state와 useState 훅의 가장 큰 차이는 무엇인가? state 훅은 상태를 병합하지 않고 대체한다.
