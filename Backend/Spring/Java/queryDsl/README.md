# 인프런 영한님 QueryDSL 강의
## 초급
### 1. 설정
- 설정 파일 모두 설정 후 `gradle - tasks - other`의 compileQueryDsl을 실행해서 잘 되는지 확인할 것

### 2. 장점
- 복잡한 쿼리 작성 시 컴파일 에러 단계에서 잘못된 쿼리를 다 잡아준다.
- 자동으로 파라미터 바인딩을 해주기 때문에 성능상의 이점과 SQL 인젝션 방어에 유리하다.
- 쿼리 작성 시 IDE 도움을 받을 수 있다. 

### 3. QType
- 보통 컴파일 시 자동을 생성되기 때문에 그거 사용하면 편하다.
- 직접 선언해주는 방법도 있다. (같은 테이블 조인할 때는 직접 선언해야만 한다.)

### 4. 검색
- 생각하는 웬만한 조건절은 다 들어있다. (contain, in, startWith 등등)

### 5. 결과 조회
- fetch: 리스트 조회. 데이터 없으면 빈 배열 반환
- fetchOne: 단건 조회. 데이터 없으면 null 반환 / 데이터가 둘 이상이면 NonUniqueResultException 발생
- fetchFist: fetchOne에 limit 1을 걸어서 쿼리 실행
- fetchResults: 페이징 정보를 포함해서 결과 반환
    - 성능이 중요한 페이징 처리 시에는 이거 쓰지 말고 아래 fetchCount 쿼리를 따로 만들어서 처리해라
- fetchCount: 단순한 count 쿼리

### 6. 정렬
- 마찬가지로 알고 있는 정렬 앵간한 거 다 된다.
- null인 경우 뒤로 미루고 하는 짓도 가능하다.

### 7. 페이징
- offset, limit을 설정해서 구현할 수 있다.
    - limit: 한번에 불러올 데이터의 양
    - offset: 0부터 시작하며, 건너뛸 페이지의 수
    
### 8. 집합
- 조회된 데이터를 연산 처리된 결과로 받아 볼 수 있다.
- 기본 데이터 타입이 tuple이기 때문에 결과값 조회 시 tuple 조회해야 하는 점에 주의하자
    - 여러개의 데이터 타입을 사용하면 tuple을 사용한다.
    
### 9. 조인
- 일반적인 조인처럼 쓰면 된다.
- Theta Join을 쓰면 아무런 연관관계 없이도 데이터를 조인시킬 수 있다.
    - 단, on 메서드 없이는 outer join을 할 수 없다.
    - DB가 성능 최적화는 해준다.
    - 물론 성능 최적화 믿고 막 썼다가는 데이터 뻥튀기되면서 망할 수 있다.
- 막 조인할 때는 객체의 연관관계 명시 없이 그냥 불러오고 싶은 객체를 조인절에 넣고 on 메서드를 추가한다.

### 10. 페치 조인
- SQL에서 적용되는 기능은 아님
- 성능 최적화를 위해 JPA에서 쓰는 특이사항

### 11. 서브 쿼리
- 쿼리 안의 쿼리
- JPAExpressions를 사용한다.
- 그래봤자 JPQL 빌더기 때문에 from 절의 서브쿼리는 지원하지 않는다.

### 12. Case문
- 앵간한 건 다 있음

## 중급
### 1. 프로젝션
- QeuryDSL을 통해 불러온 자료를 보는 것
- 단일 타입일 경우 명확한 리턴 타입을 지정해서 볼 수 있다.
- 여러개의 타입을 반환할 경우 DTO나 Tuple로 받아야 한다.
    - Tuple은 QueryDSL에서 제공하는 조회를 위한 타입이다.
- Tuple은 리포지토리 레이어를 넘기지 않도록 하는 게 좋다. (QueryDSL 종속성을 감추가 위해)

### 2. DTO 프로젝션
- JPQL을 사용할 때 쓰던 지저분한 방법보다는 많이 개선됐다.
- 프로퍼티 접근, 필드 직접 접근, 생성자 사용 세가지 방식 모두 지원한다.
    - 단, 기본 생성자 필수다. (JPA와 다르게 protected는 안된다.)
- 불러오는 Entity와 프로젝션 할 DTO의 필드 이름이 다르다면 as 메서드를 사용하면 된다.
    - 서브쿼리를 쓸 때는 ExpressionUtils.as 메서드를 사용하면 된다.
    - 생성자 방식을 통해 프로젝션 하는 경우에는 상관 없다(어차피 타입만 확인한다)
    
### 3. Qeury 프로젝션
- DTO의 생성자에 QueryProjection 어노테이션을 달아주고 QueryDSL 컴파일을 해줘야 한다.
- 컴파일 에러 차원에서 쿼리 오류를 잡아줄 수 있다.
- 안정성이 굉장히 높은 방식이지만, 레이어 간 경계를 모호하게 만드는 단점이 있다.
    - DTO가 QueryDSL 의존성을 갖기 때문
