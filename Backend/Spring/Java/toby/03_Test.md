## 2장. 테스트
- IoC/DI와 더불어 스프링의 핵심을 이루는 축 중 하나
- IoC/DI가 객체지향 설계와 구현에 도움을 준다면, 테스트는 변화에 대한 확신을 주는 도구

### 2.1. 테스트는 어때야 할까
- 테스트는 왜 하는가?
    - 내가 예상하고 의도했던대로 코드가 동작하는지 정확히 확인하고 만든 코드에 확신을 부여하는 작업
    - 이 선행 조건이 없으면 리팩토링을 안심하고 수행할 수 없다.
    - 즉, 변화에 두려움을 갖고 변화를 만들지 않으려 하게 된다.
- 통합 테스트의 문제점
    - 책에서 예시로 든, 그리고 가장 많이 사용하는 웹의 통합 테스트를 수행하면 엮여있는 것들이 너무 많다.
    - 테스트가 실패했을 때 도대체 어디서 문제가 발생한 건지 확인해야 될 부분이 너무 많고 꼬여있다.
    - 그렇다고 통합 테스트를 안해야 된다는 의미는 `절대 아니다.`
    - 통합 테스트는 유저 시나리오 테스트로써 아주 중요하다.
    - 다만 통합 테스트'만' 하면 어려울 수 있다는 의미다.
- 단위 테스트
    - 위와 같은 통합 테스트의 단점을 극복하기 위해 `작은 단위`로 나눠서 테스트하는 단위 테스트가 필요하다.
    - 여기서 `작은 단위`는 상대적이다. 상황에 따라 적절한 크기가 다르다.
    - 중요한 건 하나의 관심에 집중해서 효율적으로 테스트 할만하다면 된다.
        - 이는 개인마다 편차가 있기 때문에 개인마다 그 범위가 아주아주 다를 수 있다.
    - 또한 통제할 수 없는 외부 리소스에 의존하면, 단위 테스트라 할 수 없다.
    - 위 조건을 충족하는 단위 테스트를 만들면 개발자가 즉각적으로 자신의 코드에 대한 피드백을 얻고 빠르게 개선할 수 있다.
- 자동수행 테스트 코드
    - 테스트할 데이터가 코드를 통해 제공되고 테스트 작업 역시 코드로 자동으로 실행되는 테스트를 의미한다.
    - 모든 게 코드에 있어야 한다.
    - 이를 통해 자주 반복 수행하며 개발중인 코드에 대한 확신을 얻을 수 있다.
- 지속적인 개선과 점진적인 개발의 도구
    - 자동수행되는 단위 테스트가 없었다면 쓰래기같은 UserDao를 개선할 때 문제가 많았을 것이다.
    - 혹은 대충 하다가 넘어갔을 확률이 높다.
    - 지속적인 개선과 점진적인 개발과정으로 견고한 애플리케이션을 만들기 위해서는 자동화 된 테스트(단위, 통합)가 필수적이다.  
- UserDao Test는?
    - 위의 관점으로 봤을 때 UserDao 테스트는 수정할 사항이 꾀 있다.
    - 확인이 수동으로(사람눈으로) 이루어지기 때문에 번거롭다.
    - 실행작업을 매번 main을 돌려줘야 되기 때문에 한개일 땐 할만하지만 쌓이면 쌓일수록 과부하가 걸린다.
    
### 2.2. ~ 2.3. JUnit으로 테스트 코드 개선하기
- 테스트 실패란 무엇인가?
    - 테스트 오류: 오류에 의해 실행되던 코드가 멈추는 경우
    - 테스트 실패: 오류 없이 잘 실행됐으나, 수행 결과가 기대한 것과 다른 경우
- 현재 테스트 코드는 테스트 실패를 잡아낼 방법이 없다. (개발자가 눈으로 확인함)
- JUnit을 통해 이 테스트 검증 과정을 자동화시킬 수 있다.
- 단위 테스트는 일관성이 보장되야 한다.
    - 이전의 테스트 코드는 매번 DB의 데이터를 삭제해주거나, 이전과 다른 User 이름으로 생성해야 했다.
    - 이는 단위 테스트가 일관되게 실패하거나 성공하지 않게 되며 테스트의 신뢰드를 대폭 깎아먹게 된다.
    - 특히, 이런 현상은 외부에 테스트가 의존할 때 많이 발생한다.
    - 테스트는 외부에 의존하지 않고 늘 일관되게 작성할 수 있도록 노력해야 한다.
- 테스트가 없는 것도 문제지만 성의 없는 테스트로 위험성이 있는데 통과로 간주하고 넘어가는 테스트는 더 위험하다.
- 테스트 메서드는 한번에 한가지 경우만 검증하도록 응집도를 높여야 한다.
- JUnit은 테스트 메서드간 실행 순서를 보장하지 않으며, 메서드 간 연관이 있다면 잘못된 유닛 테스트이기 때문에 이런 동작은 당연하다.
- 테스트할 때만큼으 부정 회로를 풀가동 시켜라. 잘 되는 것만 테스트 해서는 소용 없다.
- TDD
    - 내가 `하고 싶은것`, `구현하고 싶은 것`을 코드로 표현한 뒤 기준점으로 삼고 구현을 완성하는 방법
    - BDD 스타일(given, when, then)을 쓰면 수월하게 작성할 수 있다.
    - `실패한 테스트 코드를 완성하는 코드 말고는 구현하지 않는다`라는 기본 원칙을 지키는 게 좋다.
    - 테스트 주기는 짧아야 한다. 테스트 왕창 짜고 나중에 구현하거나 반대로 하면 삽질하는 거랑 같다.
    - 왜 좋은지, 얼마나 좋은지는 생략. 하면 할수록 체감하게 된다.
- JUnit
    - 기본적으로 각 메서드를 실행할 때마다 새로운 인스턴스를 만든다.
        - 확실하게 각 테스트 메서드끼리 독립적으로 시행될 수 있도록 도와준다.
    - 각 테스트 메서드 실행 전(BeforeEach, BeforeAll), 실행 후(After)에 반복되는 일을 실행시킬 수 있다.

### 2.4. 스프링 테스트 적용
- BeforeEach 어노테이션을 통해 애플리케이션 컨텍스트를 부르면 메서드를 실행할 때마다 애플리케이션 컨텍스트를 따로 불러온다.
    - 이렇게 되면 리소스 낭비가 꾀나 심하다.
- 이를 해결하기 위해 스프링 테스트 도구를 활용하면 메서드뿐 아니라 클래스 레벨에서도 공유하는 인스턴스를 만들 수 있다.
- Spring Boot를 사용한다면 SpringBootTest 어노테이션을 활용할 수 있다.
- Autowired 어노테이션 맛보기
    - 타입에 맞는 스프링 빈을 자동으로 DI 해준다.
    - 생성자나 수정자 없이도 DI 할 수 있다. 
    - 일치하는 타입이 두개 이상일 때는 DI 할 수 없다.
- 테스트에서의 DI
    - 테스트 때는 필요하다면 구체적인 오브젝트를 DI 시켜도 된다.
        - 의도적으로 해당 오브젝트의 동작 방식을 보고 싶을 수 있기 때문이다.
    - 그래도 꼭 필요하지 않다면 테스트에서도 가능한 느슨하게 연관 관계를 맺는 편이 좋다.
- DI와 테스트
    - 절대로 구성을 바꾸지 않을 것이다. 그래도 스프링 DI를 써야 하나?
        - 당연히 써야 한다.
        - 일단 '절대'라는 건 존재하지 않는다.
    - 일단 테스트가 너무너무 쾌적해진다.
- DI를 이용한 테스트 방법
    - 1. 애플리케이션 컨텍스트 내의 빈 설정을 바꾼다.
        - DirtiesContext 어노테이션을 반드시 붙이자.
        - 이걸 안붙이면 특정 테스트 클래스에서 변경된 애플리케이션 컨텍스트가 모든 테스트 클래스에 적용된다.
    - 2. 테스트용 애플리케이션 컨텍스트를 새로 만들어서 사용한다.
    - 3. 컨테이너가 없이 테스트 코드를 작성한다.
        - 일반적으로 가장 좋은 방안이다. (가장 우선적으로 고려하자)
        - 스프링 빈은 비침투적인 성격을 갖고 있기 때문에 얼마든지 이렇게 구성할 수 있다. 

### 2.5 학습 테스트
- 왜 하냐?
    - 프레임워크 호환성 검증을 도와준다.
    - 테스트 코드 작성 훈련을 겸할 수 있다.
    - 문서만 찍 보는 것보단 재밌다. (학습 효율 상승)
- 버그 테스트
    - 학습 테스트와 유사하지만 목적이 다르다(버그 해결)
    - 왜 하냐?
        - 어차피 버그 해결하려면 현상 재현해야 한다.
        - 이걸 무식하게 웹 서버에서 누르면서 테스트하기 보다 코드로 표현하면 명확한 분석이 가능하다.
        - 문제 원인을 정확하게 찾고, 해당 문제에 연관된 관심사를 집중시킬 수 있다.
        - 비슷한 문제가 생겼을 때 현상을 재현할 수 있는 근거 자료를 만들 수 있다.
