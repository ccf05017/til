## AOP
- 얼핏 보면 OOP를 대체하기 위해 나타난 것 같다.
- 실상은 그게 아니다. 왜 나왔는지 어떤 목적으로 사용하는지 잘 고민하자.
- 예제에서는 가장 인기있는 AOP 적용 지점인 `선언적 트랜잭션`에 대해 살펴보자

### 7.1. 트랜잭션 코드의 분리
- Service 레이어에서 트랜잭션을 관리하는 코드를 보면 복잡하게 얽힌 것처럼 보이지만 명확하게 나눌 수 있다.
- 비즈니스 로직을 수행하는 부분과 트랜잭션 경계를 설정하는 부분이 명확하게 나눠져 있다.
- 지금까지 해온 기초적인 방식으로 리팩토링을 진행할 수 있다. => 메서드 분리, 클래스 분리
- DI를 이용한 클래스 분리
    - 클래스 분리를 구체 클래스로 진행하면 이전부터 지겹도록 겪은 문제(강하게 결합된 코드)를 겪을 것이다.
    - 이번에도 DI를 통해 해결해보자.
    - 이전과 다른점이라면 이번에 DI를 통해 두가지의 구현체를 구현한다.
    - 이 구현체는 같은 동작에 대해 서로 다른 영역을 담당하는 협력하는 오브젝트들이 될 것이다.
- DI를 이용한 분리의 이점
    - 비즈니스 로직을 작성할 때 로우레벨 기술(트랜잭션)에 신경쓰지 않아도 된다.
    - 오브젝트 간 연관성을 줄이고 단위 테스트를 좀 더 수월하게 진행할 수 있다.

### 7.2. 고립된 단위 테스트
- 작은 단위 테스트는 이점이 매우 많다.
  - 실패 원인을 찾기가 쉽다.
  - 관리하기가 쉽다.
  - 빠뜨린 요구사항을 점검하기 좋다.
- 하지만 매번 단위 테스트를 사용할 수는 없다.
  - 여러 오브젝트끼리 의존하는 경우에 작은 단위 테스트를 매우 힘들게 만든다.
  - 그리고 대부분의 애플리케이션은 복잡한 오브젝트 의존관계를 갖는다.
- 이런 상황에서 작은 단위 테스트를 하기 위해 `Mock을 통한 대상 오브젝트 고립` 전략을 사용할 수 있다.
  - 기본적으로 Mock은 테스트 Stub과 유사하다.
  - Mock 오브젝트는 작은 단위 테스트의 이점뿐 아니라 가벼운 테스트 환경 제공을 통한 테스트 코드 성능 향상 효과도 있다.
  - Mock 오브젝트를 직접 구현할 수도 있지만 `Mockito`가 있는데 굳이 구현해서 쓸 이유는 없다.
- 단위 테스트 vs. 통합 테스트
  - 기본적으로 단위 테스트를 먼저 고려한다.
  - 반드시 외부 리소스를 사용한 테스트가 필요할 때 통합 테스트를 고려하자
  - 둘은 서로 상호 보완적이다. 배타적인 관계가 아니기 때문에 서로 단점을 잘 보완할 수 있도록 구현하자.
  - 통합 테스트는 전문적인 QA와 전혀 다른 분야다. 통합 테스트로 QA를 대체할 생각 하지 말자.
  
### 7.3. 다이내믹 프록시와 팩토리 빈
- 단순 확장성만을 고려한다면 전략 패턴으로 처리할 수 있다.
  - 하지만 전략 패턴을 사용하면 `어떤 전략을 사용한다는 사실`이 코드에 남게 된다.
- 아예 성격이 다른 코드들이 엉켜서 기능을 구현해야 될 경우에는 위와 같이 `무엇을 적용했다는 사실까지` 감추고 싶을 때가 있다.
  - 특히 도메인 관심사와 해당 도메인을 수행하기 위한 기술 관심사가 엉키는 경우에 위와 같은 문제가 많이 발생한다.
- 이를 해결하기 위해서는 클라이언트가 부가 기능을 호출하고 부가기능이 핵심기능을 호출하는 방식이 있다.
  - 클라이언트 코드 -> 부가기능 코드 -> 핵심기능 코드
  - 문제는 클라이언트 코드가 부가기능 대신 핵심기능 코드를 바로 접근하면 여전히 문제가 발생한다.
- 문제점이 더 적은 깔끔한 코드를 위해 부가기능과 핵심기능의 공통 인터페이스를 추출하고 클라이언트 코드가 인터페이스만으로 접근하도록 강제하면 된다.
  - 이렇게 되면 클라이언트 코드는 무조건 부가기능을 통해 핵심기능으로 접근하게 된다.
- 이 때 부가기능 코드의 역할이 대리자와 비슷하다 하여 `프록시`라고 한다.
- 프록시는 역할에 따라 `데코레이터 패턴`, `프록시 패턴`이라 불리운다.
- 데코레이터 패턴
  - 타깃에 부가적인 기능을 런타임 시 다아내믹하게 부여하기 위해 프록시를 사용하는 패턴
  - 런타임 시에만 데코레이터 간 혹은 타깃과 데코레이터 간 관계가 나타나며 동작한다.
  - 여러개의 데코레이터를 중복해서 사용할 수 있다.
  - 타깃 코드의 구현과 인터페이스를 `변경하지 않고` 타깃 코드에 새로운 기능을 부여할 수 있는 디자인 패턴
- 프록시 패턴
  - 타깃에 대한 접근 방법을 제어한다.
  - 특히 타깃 오브젝트의 생성 방식이 복잡하거나 당장 필요하지 않은 경우 프록시를 통해 레퍼런스만 제공하고 진짜 필요할 때 불러올 수 있다.
    - Lazy 연산을 오브젝트에 수행할 수 있도록 도와준다.
  - 원격 오브젝트를 사용할 때도 좋은 방법이 된다.
  - 이 외에도 특정 레이어에서는 읽기만 가능하도록 제어하는 등 접근 방법을 제어할 수 있다.
- 다애니믹 프록시
  - 프록시는 많은 이점이 있지만 구현하기 너무너무 귀찮다.
    - 이걸 쓰느니 그냥 코드를 고치고 만다!
  - 뿐만 아니라 코드 중복을 발생시킬 가능성이 매우 높다.
  - 이를 해결하기 위한 방법 중 `다이내믹 프록시`가 있으며, `다이내믹 프록시`는 `리플렉션`을 사용한다.
  - 리플렉션
    - 자바 코드 자체를 `추상화`시켜서 접근하도록 만든 것.
    - 자바의 모든 클래스는 Class 타입의 오브젝트를 갖고 있으며, 이를 통해 해당 클래스의 메타 정보에 접근하거나 조작할 수 있다.
  - 다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트다.
    - 타깃 오브젝트 인터페이스만 제공하면 알아서 슥슥 프록시를 만들어준다. (수고로움 -1)
    - 만들어진 프록시에 부여하고 싶은 부가기능 코드가 담긴 InvocationHandler를 적용하면 프록시 적용 끝
      - 물론 부가기능 코드는 직접 구현해야 한다.
      - InvocationHandler는 invoke 메서드에서 타깃 오브젝트 클래스의 모든 메타 정보를 넘겨 받고 실행을 위임한다.
      - 그 덕분에 프록시를 구현할 때 매번 모든 타깃 클래스의 인터페이스를 구현하지 않아도 된다.
    - 하지만 막상 구현해보면 이것도 그렇게 간단하지만은 않다.
      - 물론 그렇다고 아예 장점이 없진 않다.
      - 타깃 클래스의 인터페이스가 늘어나도 알아서 만들어주기 때문에 일일이 대응할 필요 없다.
      - 또한 타깃 클래스 타입에 제한이 없다. 어떤 클래스가 오건 어차피 Method 타입을 invoke 시키기만 하면 된다.
    - 단, 리플렉션을 이용한 다이내믹 프록시는 너무 유연하기 때문에 주의해야 한다.
      - 만약 타깃 메서드의 결과 타입이 String이 아니라면? 원하는 메서드를 한정하고 싶다면? 등등
      - 너무 유연한 조건을 내가 필요한만큼 조건을 뜯어서 확인할 수 있도록 제한해야 한다.
    - 다이내믹 프록시를 DI 시키려면 어떻게 할까?
      - 안타깝게도 직접 할 방법이 없다. (런타임까지는 이게 뭔지도 모르기 때문)
      - 이를 해결하기 위해서는 스프링 설정에 `팩토리 빈`을 추가해줘야 한다.
      - 프록시 오브젝트 외에 생성자가 private인 오브젝트처럼 직접 등록하기 어려운 오브젝트들은 `팩토리 빈`을 사용할 수 있다.
    - 팩토리 빈
      - FactoryBean<?> 인터페이스를 상속해서 구현할 수 있다.
      - 이 팩토리 빈을 설정에 등록하면 해당 팩토리 빈이 생성하는 빈 타입을 일반 빈처럼 사용할 수 있다.
      - 팩토리 빈 자체의 빈을 불러오고 싶다면 생성되는 빈의 타입앞에 '&'를 붙여서 Resource로 불러오면 된다.
    - 프록시 팩토리 빈
      - 팩토리 빈을 이용해서 Proxy 빈을 런타임 때 동적으로 생성해주는 기술.
      - 타깃의 타입에 상관 없이 재사용할 수 있기 때문에 한번 만들어두면 여기저기 사용할 수 있다.
      - 하지만 여전히 부족하다. 클래스의 메소드가 아닌 `여러 클래스에 적용`하긴 `힘들다`.
      - 특히, 여러 클래스에 적용하면 설정 파일이 기하급수적으로 커진다.
  
  ### 7.4. 스프링의 프록시 팩토리 빈
  - 하지만 늘 그렇듯 스프링 나름의 프록시 팩토리 빈의 단점에 대한 해결책을 갖고 있다.
  - 트랜잭션, 메일과 같이 스프링은 프록시에 대한 추상화 기술을 인터페이스 형태로 제공한다.
  - 스프링의 ProxyFactoryBean은 `프록시를 생성`해서 `빈 오브젝트로 등록`하게 해주는 팩토리 빈이다.
    - 다이내믹 프록시와 다르게 생성된 오브젝트를 `빈으로 등록`까지 해준다.
    - 이 덕분에 팩토리 빈은 생성에만 전념하고, 프록시 빈은 부가기능에 대한 책임을 별도로 가질 수 있다.
  - ProxyFactoryBean이 생성한 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현한다.
    - InvocationHandler와 다르게 타깃 오브젝트에 대한 정보를 ProxyFactoryBean으로부터 MethodInvocation 파라미터로 전달 받는다.
    - 이 덕분에 타깃 오브젝트와 전혀 무관하게 독립적으로 구현할 수 있다.
    - `MethodInvocation은 일종의 콜백 오브젝트`로 공유 가능한 템플릿처럼 사용할 수 있다.
    - 즉, 싱글톤으로 등록해서 사용할 수 있다는 의미다.
    - 마지막으로 인터페이스 자동 추출 기능을 통해 타깃 클래스의 인터페이스 정보를 알아낸다.
  - 위와 같이 MethodInterceptor를 구현하여 부가기능을 부여하는 코드를 `어드바이스`라 부른다.
  - ProxyFactoryBean은 기본적으로 JDK가 제공하는 다이내믹 프록시를 사용한다.
    - 하지만 최근에는 CGLib을 통한 프록시 생성을 더 많이 한다.