## AOP
- 얼핏 보면 OOP를 대체하기 위해 나타난 것 같다.
- 실상은 그게 아니다. 왜 나왔는지 어떤 목적으로 사용하는지 잘 고민하자.
- 예제에서는 가장 인기있는 AOP 적용 지점인 `선언적 트랜잭션`에 대해 살펴보자

### 7.1. 트랜잭션 코드의 분리
- Service 레이어에서 트랜잭션을 관리하는 코드를 보면 복잡하게 얽힌 것처럼 보이지만 명확하게 나눌 수 있다.
- 비즈니스 로직을 수행하는 부분과 트랜잭션 경계를 설정하는 부분이 명확하게 나눠져 있다.
- 지금까지 해온 기초적인 방식으로 리팩토링을 진행할 수 있다. => 메서드 분리, 클래스 분리
- DI를 이용한 클래스 분리
    - 클래스 분리를 구체 클래스로 진행하면 이전부터 지겹도록 겪은 문제(강하게 결합된 코드)를 겪을 것이다.
    - 이번에도 DI를 통해 해결해보자.
    - 이전과 다른점이라면 이번에 DI를 통해 두가지의 구현체를 구현한다.
    - 이 구현체는 같은 동작에 대해 서로 다른 영역을 담당하는 협력하는 오브젝트들이 될 것이다.
- DI를 이용한 분리의 이점
    - 비즈니스 로직을 작성할 때 로우레벨 기술(트랜잭션)에 신경쓰지 않아도 된다.
    - 오브젝트 간 연관성을 줄이고 단위 테스트를 좀 더 수월하게 진행할 수 있다.

### 7.2. 고립된 단위 테스트
- 작은 단위 테스트는 이점이 매우 많다.
  - 실패 원인을 찾기가 쉽다.
  - 관리하기가 쉽다.
  - 빠뜨린 요구사항을 점검하기 좋다.
- 하지만 매번 단위 테스트를 사용할 수는 없다.
  - 여러 오브젝트끼리 의존하는 경우에 작은 단위 테스트를 매우 힘들게 만든다.
  - 그리고 대부분의 애플리케이션은 복잡한 오브젝트 의존관계를 갖는다.
- 이런 상황에서 작은 단위 테스트를 하기 위해 `Mock을 통한 대상 오브젝트 고립` 전략을 사용할 수 있다.
  - 기본적으로 Mock은 테스트 Stub과 유사하다.
  - Mock 오브젝트는 작은 단위 테스트의 이점뿐 아니라 가벼운 테스트 환경 제공을 통한 테스트 코드 성능 향상 효과도 있다.
  - Mock 오브젝트를 직접 구현할 수도 있지만 `Mockito`가 있는데 굳이 구현해서 쓸 이유는 없다.
- 단위 테스트 vs. 통합 테스트
  - 기본적으로 단위 테스트를 먼저 고려한다.
  - 반드시 외부 리소스를 사용한 테스트가 필요할 때 통합 테스트를 고려하자
  - 둘은 서로 상호 보완적이다. 배타적인 관계가 아니기 때문에 서로 단점을 잘 보완할 수 있도록 구현하자.
  - 통합 테스트는 전문적인 QA와 전혀 다른 분야다. 통합 테스트로 QA를 대체할 생각 하지 말자.
  
### 7.3. 다이내믹 프록시와 팩토리 빈
- 단순 확장성만을 고려한다면 전략 패턴으로 처리할 수 있다.
  - 하지만 전략 패턴을 사용하면 `어떤 전략을 사용한다는 사실`이 코드에 남게 된다.
- 아예 성격이 다른 코드들이 엉켜서 기능을 구현해야 될 경우에는 위와 같이 `무엇을 적용했다는 사실까지` 감추고 싶을 때가 있다.
  - 특히 도메인 관심사와 해당 도메인을 수행하기 위한 기술 관심사가 엉키는 경우에 위와 같은 문제가 많이 발생한다.
- 이를 해결하기 위해서는 클라이언트가 부가 기능을 호출하고 부가기능이 핵심기능을 호출하는 방식이 있다.
  - 클라이언트 코드 -> 부가기능 코드 -> 핵심기능 코드
  - 문제는 클라이언트 코드가 부가기능 대신 핵심기능 코드를 바로 접근하면 여전히 문제가 발생한다.
- 문제점이 더 적은 깔끔한 코드를 위해 부가기능과 핵심기능의 공통 인터페이스를 추출하고 클라이언트 코드가 인터페이스만으로 접근하도록 강제하면 된다.
  - 이렇게 되면 클라이언트 코드는 무조건 부가기능을 통해 핵심기능으로 접근하게 된다.
- 이 때 부가기능 코드의 역할이 대리자와 비슷하다 하여 `프록시`라고 한다.
- 프록시는 역할에 따라 `데코레이터 패턴`, `프록시 패턴`이라 불리운다.
- 데코레이터 패턴
  - 타깃에 부가적인 기능을 런타임 시 다아내믹하게 부여하기 위해 프록시를 사용하는 패턴
  - 런타임 시에만 데코레이터 간 혹은 타깃과 데코레이터 간 관계가 나타나며 동작한다.
  - 여러개의 데코레이터를 중복해서 사용할 수 있다.
  - 타깃 코드의 구현과 인터페이스를 `변경하지 않고` 타깃 코드에 새로운 기능을 부여할 수 있는 디자인 패턴
- 프록시 패턴
  - 타깃에 대한 접근 방법을 제어한다.
  - 특히 타깃 오브젝트의 생성 방식이 복잡하거나 당장 필요하지 않은 경우 프록시를 통해 레퍼런스만 제공하고 진짜 필요할 때 불러올 수 있다.
    - Lazy 연산을 오브젝트에 수행할 수 있도록 도와준다.
  - 원격 오브젝트를 사용할 때도 좋은 방법이 된다.
  - 이 외에도 특정 레이어에서는 읽기만 가능하도록 제어하는 등 접근 방법을 제어할 수 있다.
- 다애니믹 프록시
  - 프록시는 많은 이점이 있지만 구현하기 너무너무 귀찮다.
    - 이걸 쓰느니 그냥 코드를 고치고 만다!
  - 뿐만 아니라 코드 중복을 발생시킬 가능성이 매우 높다.
  - 이를 해결하기 위한 방법 중 `다이내믹 프록시`가 있으며, `다이내믹 프록시`는 `리플렉션`을 사용한다.
  - 리플렉션
    - 자바 코드 자체를 `추상화`시켜서 접근하도록 만든 것.
    - 자바의 모든 클래스는 Class 타입의 오브젝트를 갖고 있으며, 이를 통해 해당 클래스의 메타 정보에 접근하거나 조작할 수 있다.
  - 다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트다.
    - 타깃 오브젝트 인터페이스만 제공하면 알아서 슥슥 프록시를 만들어준다. (수고로움 -1)
    - 만들어진 프록시에 부여하고 싶은 부가기능 코드가 담긴 InvocationHandler를 적용하면 프록시 적용 끝
      - 물론 부가기능 코드는 직접 구현해야 한다.
      - InvocationHandler는 invoke 메서드에서 타깃 오브젝트 클래스의 모든 메타 정보를 넘겨 받고 실행을 위임한다.
      - 그 덕분에 프록시를 구현할 때 매번 모든 타깃 클래스의 인터페이스를 구현하지 않아도 된다.
    - 하지만 막상 구현해보면 이것도 그렇게 간단하지만은 않다.
      - 물론 그렇다고 아예 장점이 없진 않다.
      - 타깃 클래스의 인터페이스가 늘어나도 알아서 만들어주기 때문에 일일이 대응할 필요 없다.
      - 또한 타깃 클래스 타입에 제한이 없다. 어떤 클래스가 오건 어차피 Method 타입을 invoke 시키기만 하면 된다.
    - 단, 리플렉션을 이용한 다이내믹 프록시는 너무 유연하기 때문에 주의해야 한다.
      - 만약 타깃 메서드의 결과 타입이 String이 아니라면? 원하는 메서드를 한정하고 싶다면? 등등
      - 너무 유연한 조건을 내가 필요한만큼 조건을 뜯어서 확인할 수 있도록 제한해야 한다.
    - 다이내믹 프록시를 DI 시키려면 어떻게 할까?
      - 안타깝게도 직접 할 방법이 없다. (런타임까지는 이게 뭔지도 모르기 때문)
      - 이를 해결하기 위해서는 스프링 설정에 `팩토리 빈`을 추가해줘야 한다.
      - 프록시 오브젝트 외에 생성자가 private인 오브젝트처럼 직접 등록하기 어려운 오브젝트들은 `팩토리 빈`을 사용할 수 있다.
    - 팩토리 빈
      - FactoryBean<?> 인터페이스를 상속해서 구현할 수 있다.
      - 이 팩토리 빈을 설정에 등록하면 해당 팩토리 빈이 생성하는 빈 타입을 일반 빈처럼 사용할 수 있다.
      - 팩토리 빈 자체의 빈을 불러오고 싶다면 생성되는 빈의 타입앞에 '&'를 붙여서 Resource로 불러오면 된다.
    - 프록시 팩토리 빈
      - 팩토리 빈을 이용해서 Proxy 빈을 런타임 때 동적으로 생성해주는 기술.
      - 타깃의 타입에 상관 없이 재사용할 수 있기 때문에 한번 만들어두면 여기저기 사용할 수 있다.
      - 하지만 여전히 부족하다. 클래스의 메소드가 아닌 `여러 클래스에 적용`하긴 `힘들다`.
      - 특히, 여러 클래스에 적용하면 설정 파일이 기하급수적으로 커진다.
  
### 7.4. 스프링의 프록시 팩토리 빈
- 하지만 늘 그렇듯 스프링 나름의 프록시 팩토리 빈의 단점에 대한 해결책을 갖고 있다.
- 트랜잭션, 메일과 같이 스프링은 프록시에 대한 추상화 기술을 인터페이스 형태로 제공한다.
- 스프링의 ProxyFactoryBean은 `프록시를 생성`해서 `빈 오브젝트로 등록`하게 해주는 팩토리 빈이다.
  - 다이내믹 프록시와 다르게 생성된 오브젝트를 `빈으로 등록`까지 해준다.
  - 이 덕분에 팩토리 빈은 생성에만 전념하고, 프록시 빈은 부가기능에 대한 책임을 별도로 가질 수 있다.
- ProxyFactoryBean이 생성한 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현한다.
  - InvocationHandler와 다르게 타깃 오브젝트에 대한 정보를 ProxyFactoryBean으로부터 MethodInvocation 파라미터로 전달 받는다.
  - 이 덕분에 타깃 오브젝트와 전혀 무관하게 독립적으로 구현할 수 있다.
  - `MethodInvocation은 일종의 콜백 오브젝트`로 공유 가능한 템플릿처럼 사용할 수 있다.
  - 즉, 싱글톤으로 등록해서 사용할 수 있다는 의미다.
  - 마지막으로 인터페이스 자동 추출 기능을 통해 타깃 클래스의 인터페이스 정보를 알아낸다.
- 위와 같이 MethodInterceptor를 구현하여 부가기능을 부여하는 코드를 `어드바이스`라 부른다.
- ProxyFactoryBean은 기본적으로 JDK가 제공하는 다이내믹 프록시를 사용한다.
  - 하지만 최근에는 CGLib을 통한 프록시 생성을 더 많이 한다.
- 포인트컷
  - 부가기능을 적용할 메서드를 선별하는 책임을 진 오브젝트
  - 어드바이스는 타깃 오브젝트와 분리되어 있기 때문에 타깃 오브젝트의 특정 메서드를 선정하는 데 어려움이 있다. 이를 해결하기 위한 방법.
- 어드바이저
  - 어드바이스 + 포인트컷
  - JDK 다이내믹 프록시와 다르게 Spring ProxyFactoryBean에서는 어드바이스와 포인트컷을 쌍으로 묶은 어드바이저를 전달해야 한다.
    - 두 오브젝트가 여러 장소에서 사용될 수 있기 때문에 오브젝트 간 조합을 유연하게 가져가면서도 재사용성을 높이기 위한 방안이다.
  - 템플릿 콜백 패턴을 발전시킨 전략 패턴의 전형적인 예시.
  - JDK 다이내믹 프록시가 `부가기능 부여`, `적용 메서드 선정` 두가지 책임을 지고 있기 때문에 OCP를 완벽하게 지키지 못하던 현상을 해결한다.
  - 두가지 책임을 각기 다른 별개의 오브젝트에 콜백 템플릿 형식으로 위임함으로써 유연한 설계가 가능하게 도와준다.

### 7.5 스프링 AOP
- 스프링 ProxyFactoryBean을 통해 매번 부가기능 코드를 추가하고, 타깃 메서드 선정 방식을 별도로 유지할 수 있다.
- 하지만 여전히 다른 타깃 오브젝트에 부가기능을 적용하고 싶다면 매번 비슷하게 생긴 설정을 추가해야 한다.
```java
// 이런 설정들
@Bean(name = "userService")
public ProxyFactoryBean txProxyFactoryBean() {
    ProxyFactoryBean proxyFactoryBean = new ProxyFactoryBean();
    proxyFactoryBean.addAdvisor(transactionAdvisor());
    return proxyFactoryBean;
}
```
- 중복 문제를 어떻게 풀어왔을까?
  - 전략패턴과 DI
    - 반복되는 부분과 반복되지 않는 부분을 구분하고 `클라이언트`, `템플릿`, `콜백`에게 책임을 분배함으로써 해결했다.
  - 프록시 클래스 코드
    - 의미 있는 부가기능 로직은 코드를 통해 작성한다.
    - 기계적인 타깃 인터페이스 구현과 위임, 부가기능 연동 부분은 자동생성하도록 작성한다.
- 하지만 프록시 빈 설정 중복을 제거하는 건 지금까지 해온 방법으로는 어렵다. 새로운 해결책이 필요하다.
- 빈 후처리기
  - Bean이 생성된 후 어플리케이션 컨텍스트에 전달되기 전에 부가적인 설정 작업을 할 수 있게 해주는 기능.
  - BeanPostProcessor 인터페이스를 구현해서 만든다.
- DefaultAdvisorAutoProxyCreator
  - 스프링이 생성하는 `빈 오브젝트의 일부`(포인트컷을 통해 판단)를 `프록시로 포장`(프록시 생성기 이용)하고 프록시를 빈으로 대신 등록시키도록 도와준다.
- 빈 후처리기를 이용한 프록시 자동생성 과정
  - Bean 설정에 의해 Bean을 생성한다.
  - 등록된 `빈 후처리기`에 생성된 Bean을 전달한다.
  - `빈 후처리기`가 포인트컷을 확인하고 부가기능 적용 대상인지 확인한다.
  - 부가기능 적용 대상인 경우 프록시를 생성해서 Bean으로 등록한다.
- 빈 후처리기를 사용하기에는 뭔가 부족한 포인트컷
  - 빈 후처리기가 프록시로 포장할 대상을 선별하려면 메서드 외 어떤 클래스를 선택할지도 알아야 한다.
  - 다행히 포인트컷은 클래스를 선택하는 기능도 원래 갖고 있다. 이전 ProxyFactoryBean은 이미 클래스 정보를 알고 있어서 사용하지 않았을 뿐
  - 적용순서는 클래스를 먼저 확인한 후 클래스가 일치하는 경우에만 메서드 일치여부를 확인한다.
  ```java
  // 원래 포인트컷은 이렇게 생겼다.
  interface Pointcut {
      ClassFilter getClassFilter();
      MethodMatcher getMethodMatcher();
  }
  ```
- 빈 후처리기를 사용한 후의 단점?
  - 굳이 꼽자면 Spring 의존도가 올라가서 테스트에 스프링이 깊숙히 관여해야 한다.
  - 이 때문에 테스트 코드만 보고 테스트 내용을 파악하기 좀 더 어려워졌다. Bean 설정도 알아야 하기 때문이다.
- XML 설정을 사용할 경우 자바 설정과 다르게 특이한 일들을 몇가지 할 수 있다.
  - parent 값으로 bean 설정을 상속받거나, static 클래스를 bean으로 등록할 수 있다.
  - Java 설정에서도 불가능한 건 아니지만 굳이 사용할 이유가 없어서 다른 방안으로 접근할 수 있다.
- 포인트컷 표현식
  - 포인트컷을 매번 클래스명, 메서드명으로 복잡하게 설정하긴 너무 귀찮다.
  - AspectJ를 확장한 `AspectJ 포인트컷 표현식`을 이용하면 더 쉽게 프록시 적용 대상을 선별할 수 있다.
    - Regex를 사용할 수 있도록 도와준다.
  - 포인트컷 표현식 문법은 여러 방법으로 타깃 오브젝트를 지정할 수 있도록 도와준다.
    - execution(): 포인트컷 표현식 문법을 통해 타깃 오브젝트를 지정한다. (상세 문법에 대해서는 토비의 스프링 491페이지부터 참조)
    - annotation(): 특정 이름을 가진 어노테이션을 대상으로 지정한다.
    - bean(): 특정 Bean의 이름을 가진 오브젝트를 대상으로 지정한다.
  - 포인트컷 표현식은 코드와 설정이 매우 단순해지지만, 문자열 방식이기 때문에 런타임까지 오류를 발견하기가 매우 어렵다.
  - 그만큼 포인트컷 표현식을 사용하기 전에 철저한 검증을 거쳐야 한다.
    - 추가로 스프링에서 포인트컷 표현식 검증을 편하게 수행하기 위한 도구들이 제공된다.
  - 주의사항
    - 포인트컷 표현식 요소 중 `타입 패턴`이라 명시된 친구들은 말 그대로 `타입의 이름`을 비교한다.
    - 예를 들어, 표현식에서 클래스를 지정하는 경우 해당 클래스명이 아니라 `클래스 타입의 이름을 기준`으로 타깃 오브젝트를 선별한다.
    - 생으로 AspectJ 포인트컷을 테스트하고 싶다면 `Pointcut Weaver` 의존성을 추가해야 한다.
- 그나저나 지금까지 뭘 한거지?
  - 부가기능 코드를 어떻게 관리할지에 대해 고민하고 있었다.
  - 일반적인 핵심 비즈니스 로직은 관심사 분리를 통해 대부분의 문제를 해결 할 수 있었다.
  - 하지만 트랜잭션 기능과 같은 부가기능은 모듈화가 어렵다.
    - 타깃이 존재해야만 작동하는 코드이기 때문이다.
  - 이 문제를 해결하기 위해 많은 개발자들이 고민했다 => 프록시, 데코레이터, 빈 후처리 등등이 이에 대한 결과물이다.
  - 결론적으로 부가기능을 `Advisor`라는 별도의 모듈로 분리해낼 수 있었다.
  - 이를 통해 핵심 비즈니스 로직에서 부가 기능 관심사를 걷어낼 수 있었고, 부가기능 코드는 모듈화를 통해 부가기능 구현에만 집중할 수 있게 됐다.
- 그래서 AOP는 무엇인가?
  - 부가기능을 모듈화하기 위한 기법을 통칭하는 용어
  - 부가기능을 부여하는 `어드바이스`, 부가기능을 부여할 위치를 결정하는 `포인트컷`으로 구성된다.
  - AOP를 통해 코드상으로는 부가기능과 핵심기능이 서로의 책임에 구분된 깔끔한 코드를 유지하면서 런타임 시에 다이내믹하게 결합하는 이점을 누릴 수 있다.
  - OOP의 대체재라고 착각해선 안된다. `OOP의 보조 수단`이다.
  - Aspect?
    - 부가기능은 분명 어플리케이션을 구성하는 기능의 일부이지만 전통적인 OOP 관점으로 모듈화가 어렵다.
    - 이러한 부가기능은 전통적 OOP 외의 다른 특이한 관심사를 갖고 있다고 사람들은 생각했으며, 이를 관점(Aspect)라 부른다.
- AOP 구현기술
  - 기본적으로 스프링은 `프록시`를 이용한 AOP 방식을 사용한다.
  - 하지만 필요한 경우 `바이트코드를 조작`하는 AOP 방식을 사용한다. (최근에는 이 방식을 이용한 CGLib을 많이 사용한다.)
    - 바이트코드를 조작하면 좀 더 유연하게 부가기능을 부여할 수 있다. (오브젝트 생성에 관여, static 메서드에 부가기능 부여 등)
    - 또한 스프링 컨테이너가 없는 상황에서도 오브젝트에 AOP를 적용할 수 있다.
- AOP 용어 정리
  - 타깃: 부가기능을 부여할 대상
  - 어드바이스: `타깃`에게 제공할 부가기능을 담은 모듈
  - 조인 포인트: `어드바이스`가 적용될 수 있는 위치
  - 포인트컷: `어드바이스`를 적용할 `조인포인트`를 찾아내는 작업 또는 그 기능을 정의한 모듈
  - 프록시: 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트
  - 어드바이저: `포인트컷`과 `어드바이스`를 한개씩 갖고 있는 오브젝트 (스프링에서만 사용되는 용어). `에스펙트`의 한 종류
  - 에스펙트: AOP의 기본 모듈. 한개 또는 그 이상의 `포인트컷`, `어드바이스`를 갖고 있다.
- 스프링 AOP를 적용하기 위한 요구사항
  - 자동 프록시 생성기
    - 독립적으로 존재하며, 스프링 컨텍스트가 빈을 생성할 때 빈 후처리기로 참여한다.
    - 어드바이저를 참고해서 자동으로 프록시를 생성하는 기능을 담당한다.
  - 어드바이스
    - 부가 기능을 구현한 클래스를 빈으로 등록해야 한다.
  - 포인트컷
    - expression을 property로 갖는 빈으로 등록해야 한다.
  - 어드바이저
    - 어드바이스 1개와 포인트컷 1개의 결합. 자동 검색되어 사용된다.
- AOP 설정은 전용 XML 설정 태그를 통해서도 사용할 수 있다. (그냥 쓸 때보다 좀 더 간단함)

### 7.6 트랜잭션 속성
- 트랜잭션의 주요 속성 4가지
  - 트랜잭션 전파
    - 트랜잭션 경계에서 이미 진행 중인 트랜잭션이 있을때 혹은 없을 때 어떻게 동작할 것인지 결정하는 방식
    - 이 전파 속성 때문에 TransactionManager로부터 getTransaction 메서드로 트랜잭션을 불러온다.
      - 매번 트랜잭션을 새로 실행하는 게 아니라 속성에 따라 트랜잭션을 실행하지 않을 수도 있다.
    - Propagation Required: 진행 중인 트랜잭션이 없으면 새로 실행하고 있으면 그 트랜잭션에 참여한다. (기본값)
    - Propagation Required New: 무조건 새 트랜잭션을 시작한다.
    - Propagation Not Supported: 트랜잭션에 참여하지 않는다.
  - 트랜잭션 격리
    - 가능한 한 동시에 많은 트랜잭션을 실행시키면서 동시 접근에 의한 문제가 발생하지 않도록 관리하는 옵션
    - 이거 하나만으로 매우 복잡한 주제가 되기 때문에 상세한 내용은 따로 학습하자
  - 제한시간
    - 말 그대로 타임아웃 속성
    - 과하게 큰 트랜잭션이 실행되지 않도록 정해진 시간동안만 실행하도록 제한할 수 있는 속성
  - 읽기전용
    - 트랜잭션 내에서 데이터 조작 시도 자체를 막아버린다.
    - 데이터 액세스 기술에 따라 성능이 향상되는 경우도 있다.
- 위의 네가지 주요 속성을 조정한 TransactionDefinition을 빈으로 등록하고 Transaction 부가 기능에 적용할 수 있다.
- 문제는 그렇게 되면 Transaction 부가 기능을 사용하는 모든 코드가 해당 Transaction 설정으로 동작한다.
  - 일부만 따로 설정하고 싶으면 어떡하지?
- 트랜잭션 인터셉터
  - 일부 트랜잭션에 대해서만 다른 설정을 적용하고 싶을 때 사용한다.
  - Transaction Advisor의 기능을 포함하기 때문에 인터셉터 사용 시 굳이 Advisor를 사용할 필요가 없다.
  - PlatformTransactionManager와 Properties(transactionAttributes)를 프로퍼티로 갖는다. (토비의 스프링 기준)
    - transactionAttributes 
      - 트랜잭션 관련 모든 속성과 롤백 방식을 제어할 수 있다.
      - key, map으로 이루어진 일종의 맵 자료구조
      - 적용 대상 메서드 패턴을 key로 갖는다.
      - Propagation Name, Isolation Name, readOnly, timeout_NNNN, -Exception1, -Exception2의 문자열 패턴을 값으로 갖는다.
      - Propagation Name 외에는 모두 옵션값으로 생략 가능하다.
  - 문서작성일 기준으로 SpringBoot에서 Properties를 사용하는 방식은 deprecated 됐다.
    - 현재는 TransactionManager, TransactionAttributeSource를 프로퍼티로 사용하는 걸 권장한다.
    - 해당 방법 관련 사용법은 예제 코드에 정리되어 있다.
- 스프링 트랜잭션의 롤백 방식
  - 스프링은 기본적으로 런타임 예외는 롤백시키지만 체크 예외는 롤백시키지 않는다.
  - 스프링의 기본 바탕에 체크 예외는 비즈니스적으로 의미가 있는 예외로 취급한다는 생각이 있기 때문이다.
  - 트랜잭션 인터셉터 설정을 통해 이런 기본 롤백 방식도 변경 가능하다. (체크 예외 중 일부를 롤백시킨다던가 하는 방식으로)
- Transaction readOnly 속성의 주의사항
  - readOnly 속성은 트랜잭션이 시작되는 경우에만 적용된다.
  - 예를 들어 업데이트를 실행하는 transaction 적용 메서드 안에서 readOnly 트랜잭션을 PROPAGATION_REQUIRED로 시작해도 수정 작업이 진행된다.
    - readOnly 속성으로 트랜잭션이 시작되지 않았기 때문이다.
  - 반대의 경우는 적용되지 않는다.
  - 오류가 발생하기 쉬운 매우 중요한 사항이니 꼭 알고 있어야 한다.
- 포인트컷 트랜잭션 속성의 적용 전략
  - 기본적으로 타깃 클래스의 모든 메서드는 트랜잭션 적용 대상 후보로 되는 것이 좋다.
    - 일단 모두 후보로 등록한 뒤 제거해야될 필요성이 있을때만 제거하는 게 관리하기 더 편하다.
  - 단순 조회 작업에도 트랜잭션을 적용하는 게 좋다.
    - 성능 향상이 있을 수도 있고, 만약의 사태를 방지할 수 있다.
  - 포인트컷 방식으로 트랜잭션 적용 대상을 골라낸다면, `공통 이름 규칙`을 만들거나 `인터페이스나 빈 타입에 의한 적용 대상 지정` 방식을 사용하자.
- 프록시 방식 AOP 트랜잭션의 주의사항
  - 프록시 방식 트랜잭션은 `같은 타깃 오브젝트` 내의 `메서드 사용` 시 트랜잭션 부가기능이 적용되지 않는다.
  - 프록시 방식은 클라이언트 코드가 타깃 오브젝트르 사용할 때 프록시가 중간에 끼어드는 방식이다.
  - 즉, 타깃 오브젝트가 자신의 메서드끼리 호출하면 프록시가 끼어들 틈이 없기 때문에 트랜잭션 부가기능을 적용할 수 없다.
    - 클라이언트가 타깃 오브젝트를 콜하는 순간에만 프록시가 적용된다.
  - 이런 현상을 방지해야될 때는 `바이트코드를 조작하는 방식의 AOP 사용`을 고려하자
    - Spring을 조작해서 해도 되지만, 기껏 비즈니스 코드에서 기술 종속성을 걷어냈더니 다시 가져오는 역효화가 발생한다.

### 7.7 애노테이션 트랜잭션 속성과 포인트컷
- 세밀한 트랜잭션 제어가 필요한 경우를 위해 스프링은 애노테이션을 이용한 트랜잭션 설정 방식을 제공한다.
  - 실상은 이 방법이 가장 대중적으로 널리 사용되고 있다.
- Transaction 애노테이션 타입의 특징
  - 메소드와 타입에 적용 가능하다.
    - 클래스, 인터페이스, 메서드에 사용할 수 있다는 의미다.
  - 해당 애노테이션이 부여된 오브젝트를 모두 찾아서 포인트컷 선정 대상으로 판단한다.
  - 애노테이션의 엘리먼트를 통해 트랜잭션의 속성을 정의한다.
  - 이 때문에 트랜잭션 한 줄로 포인트컷 선정, 트랜잭션 속성 정의를 한방에 끝낼 수 있다.
- 대체 정책
  - 물론 트랜잭션 어노테이션이 굉장히 편리하지만 자칫 더러운 어노테이션 덩어리를 만들어낼 수 있다.
  - 이를 방지하기 위해 `대체 정책`이 존재한다.
  - 타깃 메서드, 타깃 클래스, 선언 메서드, 선언 타입 순으로 대체 정책을 모색한다.
  - 위의 순서를 이용해서 좀 더 범용적인 속성을 상위 대체 정책에 설정하고, 세분화된 속성은 하위 대체 정책에 설정할 수 있다.

### 7.8 트랜잭션 지원 테스트
- 트랜잭션 전파 속성
  - Propagation 옵션을 통해 트랜잭션 어노테이션이 적용된 오브젝트의 트랜잭션 범위를 설정 할 수 있다.
    - 자세한 사항은 문서를 참고하자.
  - 이 전파 속성을 통해 서비스 코드의 재사용성을 높일 수 있다.
- 선언적 트랜잭션
  - AOP를 이용해 코드 외부에서 트랜잭션의 기능을 부여해주고 속성을 지정하는 방법
  - 일반적으로 선언적 트랜잭션을 사용하는 방법을 권장한다.
- 프로그램에 의한 트랜잭션
  - `TransactionTemplate`이나 `개별 데이터 기술의 트랜잭션 API`를 사용해 직접 코드 안에서 사용하는 방법
- 트랜잭션 추상화
  - 스프링의 트랜잭션은 AOP를 통해 애플리케이션 전반에 간편하게 적용할 수 있었다.
  - 그 외에도 특정 기술에 종속받지 않는 트랜잭션 추상화 또한 이를 가능케 한 큰 축 중 하나다.
  - PlatformTransactionManager 인터페이스를 통해 구체적인 트랜잭션 기술의 종속성으로부터 애플리케이션을 지켜낼 수 있었다.
  - 또한 `트랜잭션 동기화`를 통해 DAO에서 서로 공유가 가능하도록 도와준다.
- 롤백 테스트
    - 각 테스트 간에는 어떠한 의존성도 없어야 한다.
        - 특정 테스트의 수행 여부에 따라 다른 테스트의 결과값이 바뀌는 현상을 `테스트간 의존성이 있다`고 한다.
    - 문제는 DB가 포함된 통합 테스트의 경우 이런 `테스트 의존성`을 방지하기가 어렵다.
        - 테스트 수행에 따라 DB가 변화하기 때문
- 테스트 코드에서의 Transactional 어노테이션
    - 테스트 코드의 Transactional 어노테이션은 각 메서드 수행 후 자동으로 DB를 롤백시켜준다.
    - 이러한 기능을 통해 편리하게 `롤백 테스트`를 수행할 수 있다.
    - 이 외에도 단위 테스트 상의 메서드를 한 트랜잭션으로 묶어서 전파 속성에 따른 트랜잭션 묶음을 테스트할 수 있도록 도와준다.
    - 이를 응용하면 하이버네이트의 세션에서 분리된 오브젝트의 동작을 확인하기도 좋다.
    - 테스트 코드 Transactional에서 특정 메서드만 롤백을 수행하고 싶지 않을 때는 `Rollback` 어노테이션 사용을 고려해볼 수 있다.
