## AOP
- 얼핏 보면 OOP를 대체하기 위해 나타난 것 같다.
- 실상은 그게 아니다. 왜 나왔는지 어떤 목적으로 사용하는지 잘 고민하자.
- 예제에서는 가장 인기있는 AOP 적용 지점인 `선언적 트랜잭션`에 대해 살펴보자

### 7.1. 트랜잭션 코드의 분리
- Service 레이어에서 트랜잭션을 관리하는 코드를 보면 복잡하게 얽힌 것처럼 보이지만 명확하게 나눌 수 있다.
- 비즈니스 로직을 수행하는 부분과 트랜잭션 경계를 설정하는 부분이 명확하게 나눠져 있다.
- 지금까지 해온 기초적인 방식으로 리팩토링을 진행할 수 있다. => 메서드 분리, 클래스 분리
- DI를 이용한 클래스 분리
    - 클래스 분리를 구체 클래스로 진행하면 이전부터 지겹도록 겪은 문제(강하게 결합된 코드)를 겪을 것이다.
    - 이번에도 DI를 통해 해결해보자.
    - 이전과 다른점이라면 이번에 DI를 통해 두가지의 구현체를 구현한다.
    - 이 구현체는 같은 동작에 대해 서로 다른 영역을 담당하는 협력하는 오브젝트들이 될 것이다.
- DI를 이용한 분리의 이점
    - 비즈니스 로직을 작성할 때 로우레벨 기술(트랜잭션)에 신경쓰지 않아도 된다.
    - 오브젝트 간 연관성을 줄이고 단위 테스트를 좀 더 수월하게 진행할 수 있다.

### 7.2. 고립된 단위 테스트
- 작은 단위 테스트는 이점이 매우 많다.
  - 실패 원인을 찾기가 쉽다.
  - 관리하기가 쉽다.
  - 빠뜨린 요구사항을 점검하기 좋다.
- 하지만 매번 단위 테스트를 사용할 수는 없다.
  - 여러 오브젝트끼리 의존하는 경우에 작은 단위 테스트를 매우 힘들게 만든다.
  - 그리고 대부분의 애플리케이션은 복잡한 오브젝트 의존관계를 갖는다.
- 이런 상황에서 작은 단위 테스트를 하기 위해 `Mock을 통한 대상 오브젝트 고립` 전략을 사용할 수 있다.
  - 기본적으로 Mock은 테스트 Stub과 유사하다.
  - Mock 오브젝트는 작은 단위 테스트의 이점뿐 아니라 가벼운 테스트 환경 제공을 통한 테스트 코드 성능 향상 효과도 있다.
  - Mock 오브젝트를 직접 구현할 수도 있지만 `Mockito`가 있는데 굳이 구현해서 쓸 이유는 없다.
- 단위 테스트 vs. 통합 테스트
  - 기본적으로 단위 테스트를 먼저 고려한다.
  - 반드시 외부 리소스를 사용한 테스트가 필요할 때 통합 테스트를 고려하자
  - 둘은 서로 상호 보완적이다. 배타적인 관계가 아니기 때문에 서로 단점을 잘 보완할 수 있도록 구현하자.
  - 통합 테스트는 전문적인 QA와 전혀 다른 분야다. 통합 테스트로 QA를 대체할 생각 하지 말자.
