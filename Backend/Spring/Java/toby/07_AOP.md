## AOP
- 얼핏 보면 OOP를 대체하기 위해 나타난 것 같다.
- 실상은 그게 아니다. 왜 나왔는지 어떤 목적으로 사용하는지 잘 고민하자.
- 예제에서는 가장 인기있는 AOP 적용 지점인 `선언적 트랜잭션`에 대해 살펴보자

### 7.1. 트랜잭션 코드의 분리
- Service 레이어에서 트랜잭션을 관리하는 코드를 보면 복잡하게 얽힌 것처럼 보이지만 명확하게 나눌 수 있다.
- 비즈니스 로직을 수행하는 부분과 트랜잭션 경계를 설정하는 부분이 명확하게 나눠져 있다.
- 지금까지 해온 기초적인 방식으로 리팩토링을 진행할 수 있다. => 메서드 분리, 클래스 분리
- DI를 이용한 클래스 분리
    - 클래스 분리를 구체 클래스로 진행하면 이전부터 지겹도록 겪은 문제(강하게 결합된 코드)를 겪을 것이다.
    - 이번에도 DI를 통해 해결해보자.
    - 이전과 다른점이라면 이번에 DI를 통해 두가지의 구현체를 구현한다.
    - 이 구현체는 같은 동작에 대해 서로 다른 영역을 담당하는 협력하는 오브젝트들이 될 것이다.
- DI를 이용한 분리의 이점
    - 비즈니스 로직을 작성할 때 로우레벨 기술(트랜잭션)에 신경쓰지 않아도 된다.
    - 오브젝트 간 연관성을 줄이고 단위 테스트를 좀 더 수월하게 진행할 수 있다.

### 7.2. 고립된 단위 테스트
- 작은 단위 테스트는 이점이 매우 많다.
  - 실패 원인을 찾기가 쉽다.
  - 관리하기가 쉽다.
  - 빠뜨린 요구사항을 점검하기 좋다.
- 하지만 매번 단위 테스트를 사용할 수는 없다.
  - 여러 오브젝트끼리 의존하는 경우에 작은 단위 테스트를 매우 힘들게 만든다.
  - 그리고 대부분의 애플리케이션은 복잡한 오브젝트 의존관계를 갖는다.
- 이런 상황에서 작은 단위 테스트를 하기 위해 `Mock을 통한 대상 오브젝트 고립` 전략을 사용할 수 있다.
  - 기본적으로 Mock은 테스트 Stub과 유사하다.
  - Mock 오브젝트는 작은 단위 테스트의 이점뿐 아니라 가벼운 테스트 환경 제공을 통한 테스트 코드 성능 향상 효과도 있다.
  - Mock 오브젝트를 직접 구현할 수도 있지만 `Mockito`가 있는데 굳이 구현해서 쓸 이유는 없다.
- 단위 테스트 vs. 통합 테스트
  - 기본적으로 단위 테스트를 먼저 고려한다.
  - 반드시 외부 리소스를 사용한 테스트가 필요할 때 통합 테스트를 고려하자
  - 둘은 서로 상호 보완적이다. 배타적인 관계가 아니기 때문에 서로 단점을 잘 보완할 수 있도록 구현하자.
  - 통합 테스트는 전문적인 QA와 전혀 다른 분야다. 통합 테스트로 QA를 대체할 생각 하지 말자.
  
### 7.3. 다이내믹 프록시와 팩토리 빈
- 단순 확장성만을 고려한다면 전략 패턴으로 처리할 수 있다.
  - 하지만 전략 패턴을 사용하면 `어떤 전략을 사용한다는 사실`이 코드에 남게 된다.
- 아예 성격이 다른 코드들이 엉켜서 기능을 구현해야 될 경우에는 위와 같이 `무엇을 적용했다는 사실까지` 감추고 싶을 때가 있다.
  - 특히 도메인 관심사와 해당 도메인을 수행하기 위한 기술 관심사가 엉키는 경우에 위와 같은 문제가 많이 발생한다.
- 이를 해결하기 위해서는 클라이언트가 부가 기능을 호출하고 부가기능이 핵심기능을 호출하는 방식이 있다.
  - 클라이언트 코드 -> 부가기능 코드 -> 핵심기능 코드
  - 문제는 클라이언트 코드가 부가기능 대신 핵심기능 코드를 바로 접근하면 여전히 문제가 발생한다.
- 문제점이 더 적은 깔끔한 코드를 위해 부가기능과 핵심기능의 공통 인터페이스를 추출하고 클라이언트 코드가 인터페이스만으로 접근하도록 강제하면 된다.
  - 이렇게 되면 클라이언트 코드는 무조건 부가기능을 통해 핵심기능으로 접근하게 된다.
- 이 때 부가기능 코드의 역할이 대리자와 비슷하다 하여 `프록시`라고 한다.
- 프록시는 역할에 따라 `데코레이터 패턴`, `프록시 패턴`이라 불리운다.
- 데코레이터 패턴
  - 타깃에 부가적인 기능을 런타임 시 다아내믹하게 부여하기 위해 프록시를 사용하는 패턴
  - 런타임 시에만 데코레이터 간 혹은 타깃과 데코레이터 간 관계가 나타나며 동작한다.
  - 여러개의 데코레이터를 중복해서 사용할 수 있다.
  - 타깃 코드의 구현과 인터페이스를 `변경하지 않고` 타깃 코드에 새로운 기능을 부여할 수 있는 디자인 패턴
- 프록시 패턴
  - 타깃에 대한 접근 방법을 제어한다.
  - 특히 타깃 오브젝트의 생성 방식이 복잡하거나 당장 필요하지 않은 경우 프록시를 통해 레퍼런스만 제공하고 진짜 필요할 때 불러올 수 있다.
    - Lazy 연산을 오브젝트에 수행할 수 있도록 도와준다.
  - 원격 오브젝트를 사용할 때도 좋은 방법이 된다.
  - 이 외에도 특정 레이어에서는 읽기만 가능하도록 제어하는 등 접근 방법을 제어할 수 있다.
- 다애니믹 프록시
  - 프록시는 많은 이점이 있지만 구현하기 너무너무 귀찮다.
    - 이걸 쓰느니 그냥 코드를 고치고 만다!
  - 뿐만 아니라 코드 중복을 발생시킬 가능성이 매우 높다.
  - 이를 해결하기 위한 방법 중 `다이내믹 프록시`가 있으며, `다이내믹 프록시`는 `리플렉션`을 사용한다.
  - 리플렉션
    - 자바 코드 자체를 `추상화`시켜서 접근하도록 만든 것.
    - 자바의 모든 클래스는 Class 타입의 오브젝트를 갖고 있으며, 이를 통해 해당 클래스의 메타 정보에 접근하거나 조작할 수 있다.
  - 다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트다.
    - 타깃 오브젝트 인터페이스만 제공하면 알아서 슥슥 프록시를 만들어준다. (수고로움 -1)
    - 만들어진 프록시에 부여하고 싶은 부가기능 코드가 담긴 InvocationHandler를 적용하면 프록시 적용 끝
      - 물론 부가기능 코드는 직접 구현해야 한다.
      - InvocationHandler는 invoke 메서드에서 타깃 오브젝트 클래스의 모든 메타 정보를 넘겨 받고 실행을 위임한다.
      - 그 덕분에 프록시를 구현할 때 매번 모든 타깃 클래스의 인터페이스를 구현하지 않아도 된다.
    - 하지만 막상 구현해보면 이것도 그렇게 간단하지만은 않다.
      - 물론 그렇다고 아예 장점이 없진 않다.
      - 타깃 클래스의 인터페이스가 늘어나도 알아서 만들어주기 때문에 일일이 대응할 필요 없다.
      - 또한 타깃 클래스 타입에 제한이 없다. 어떤 클래스가 오건 어차피 Method 타입을 invoke 시키기만 하면 된다.
    - 단, 리플렉션을 이용한 다이내믹 프록시는 너무 유연하기 때문에 주의해야 한다.
      - 만약 타깃 메서드의 결과 타입이 String이 아니라면? 원하는 메서드를 한정하고 싶다면? 등등
      - 너무 유연한 조건을 내가 필요한만큼 조건을 뜯어서 확인할 수 있도록 제한해야 한다.
    - 다이내믹 프록시를 DI 시키려면 어떻게 할까?
      - 안타깝게도 직접 할 방법이 없다. (런타임까지는 이게 뭔지도 모르기 때문)
      - 이를 해결하기 위해서는 스프링 설정에 `팩토리 빈`을 추가해줘야 한다.
      - 프록시 오브젝트 외에 생성자가 private인 오브젝트처럼 직접 등록하기 어려운 오브젝트들은 `팩토리 빈`을 사용할 수 있다.
    - 팩토리 빈
      - FactoryBean<?> 인터페이스를 상속해서 구현할 수 있다.
      - 이 팩토리 빈을 설정에 등록하면 해당 팩토리 빈이 생성하는 빈 타입을 일반 빈처럼 사용할 수 있다.
      - 팩토리 빈 자체의 빈을 불러오고 싶다면 생성되는 빈의 타입앞에 '&'를 붙여서 Resource로 불러오면 된다.
    - 프록시 팩토리 빈
      - 팩토리 빈을 이용해서 Proxy 빈을 런타임 때 동적으로 생성해주는 기술.
      - 타깃의 타입에 상관 없이 재사용할 수 있기 때문에 한번 만들어두면 여기저기 사용할 수 있다.
      - 하지만 여전히 부족하다. 클래스의 메소드가 아닌 `여러 클래스에 적용`하긴 `힘들다`.
      - 특히, 여러 클래스에 적용하면 설정 파일이 기하급수적으로 커진다.
  
  ### 7.4. 스프링의 프록시 팩토리 빈
  - 하지만 늘 그렇듯 스프링 나름의 프록시 팩토리 빈의 단점에 대한 해결책을 갖고 있다.
  - 트랜잭션, 메일과 같이 스프링은 프록시에 대한 추상화 기술을 인터페이스 형태로 제공한다.
  - 스프링의 ProxyFactoryBean은 `프록시를 생성`해서 `빈 오브젝트로 등록`하게 해주는 팩토리 빈이다.
    - 다이내믹 프록시와 다르게 생성된 오브젝트를 `빈으로 등록`까지 해준다.
    - 이 덕분에 팩토리 빈은 생성에만 전념하고, 프록시 빈은 부가기능에 대한 책임을 별도로 가질 수 있다.
  - ProxyFactoryBean이 생성한 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현한다.
    - InvocationHandler와 다르게 타깃 오브젝트에 대한 정보를 ProxyFactoryBean으로부터 MethodInvocation 파라미터로 전달 받는다.
    - 이 덕분에 타깃 오브젝트와 전혀 무관하게 독립적으로 구현할 수 있다.
    - `MethodInvocation은 일종의 콜백 오브젝트`로 공유 가능한 템플릿처럼 사용할 수 있다.
    - 즉, 싱글톤으로 등록해서 사용할 수 있다는 의미다.
    - 마지막으로 인터페이스 자동 추출 기능을 통해 타깃 클래스의 인터페이스 정보를 알아낸다.
  - 위와 같이 MethodInterceptor를 구현하여 부가기능을 부여하는 코드를 `어드바이스`라 부른다.
  - ProxyFactoryBean은 기본적으로 JDK가 제공하는 다이내믹 프록시를 사용한다.
    - 하지만 최근에는 CGLib을 통한 프록시 생성을 더 많이 한다.
  - 포인트컷
    - 부가기능을 적용할 메서드를 선별하는 책임을 진 오브젝트
    - 어드바이스는 타깃 오브젝트와 분리되어 있기 때문에 타깃 오브젝트의 특정 메서드를 선정하는 데 어려움이 있다. 이를 해결하기 위한 방법.
  - 어드바이저
    - 어드바이스 + 포인트컷
    - JDK 다이내믹 프록시와 다르게 Spring ProxyFactoryBean에서는 어드바이스와 포인트컷을 쌍으로 묶은 어드바이저를 전달해야 한다.
      - 두 오브젝트가 여러 장소에서 사용될 수 있기 때문에 오브젝트 간 조합을 유연하게 가져가면서도 재사용성을 높이기 위한 방안이다.
    - 템플릿 콜백 패턴을 발전시킨 전략 패턴의 전형적인 예시.
    - JDK 다이내믹 프록시가 `부가기능 부여`, `적용 메서드 선정` 두가지 책임을 지고 있기 때문에 OCP를 완벽하게 지키지 못하던 현상을 해결한다.
    - 두가지 책임을 각기 다른 별개의 오브젝트에 콜백 템플릿 형식으로 위임함으로써 유연한 설계가 가능하게 도와준다.
  
  ### 7.5 스프링 AOP
  - 스프링 ProxyFactoryBean을 통해 매번 부가기능 코드를 추가하고, 타깃 메서드 선정 방식을 별도로 유지할 수 있다.
  - 하지만 여전히 다른 타깃 오브젝트에 부가기능을 적용하고 싶다면 매번 비슷하게 생긴 설정을 추가해야 한다.
  ```java
  // 이런 설정들
  @Bean(name = "userService")
  public ProxyFactoryBean txProxyFactoryBean() {
      ProxyFactoryBean proxyFactoryBean = new ProxyFactoryBean();
      proxyFactoryBean.addAdvisor(transactionAdvisor());
      return proxyFactoryBean;
  }
  ```
  - 중복 문제를 어떻게 풀어왔을까?
    - 전략패턴과 DI
      - 반복되는 부분과 반복되지 않는 부분을 구분하고 `클라이언트`, `템플릿`, `콜백`에게 책임을 분배함으로써 해결했다.
    - 프록시 클래스 코드
      - 의미 있는 부가기능 로직은 코드를 통해 작성한다.
      - 기계적인 타깃 인터페이스 구현과 위임, 부가기능 연동 부분은 자동생성하도록 작성한다.
  - 하지만 프록시 빈 설정 중복을 제거하는 건 지금까지 해온 방법으로는 어렵다. 새로운 해결책이 필요하다.
  - 빈 후처리기
    - Bean이 생성된 후 어플리케이션 컨텍스트에 전달되기 전에 부가적인 설정 작업을 할 수 있게 해주는 기능.
    - BeanPostProcessor 인터페이스를 구현해서 만든다.
  - DefaultAdvisorAutoProxyCreator
    - 스프링이 생성하는 `빈 오브젝트의 일부`(포인트컷을 통해 판단)를 `프록시로 포장`(프록시 생성기 이용)하고 프록시를 빈으로 대신 등록시키도록 도와준다.
  - 빈 후처리기를 이용한 프록시 자동생성 과정
    - Bean 설정에 의해 Bean을 생성한다.
    - 등록된 `빈 후처리기`에 생성된 Bean을 전달한다.
    - `빈 후처리기`가 포인트컷을 확인하고 부가기능 적용 대상인지 확인한다.
    - 부가기능 적용 대상인 경우 프록시를 생성해서 Bean으로 등록한다.
  - 빈 후처리기를 사용하기에는 뭔가 부족한 포인트컷
    - 빈 후처리기가 프록시로 포장할 대상을 선별하려면 메서드 외 어떤 클래스를 선택할지도 알아야 한다.
    - 다행히 포인트컷은 클래스를 선택하는 기능도 원래 갖고 있다. 이전 ProxyFactoryBean은 이미 클래스 정보를 알고 있어서 사용하지 않았을 뿐
    - 적용순서는 클래스를 먼저 확인한 후 클래스가 일치하는 경우에만 메서드 일치여부를 확인한다.
    ```java
    // 원래 포인트컷은 이렇게 생겼다.
    interface Pointcut {
        ClassFilter getClassFilter();
        MethodMatcher getMethodMatcher();
    }
    ```
  - 빈 후처리기를 사용한 후의 단점?
    - 굳이 꼽자면 Spring 의존도가 올라가서 테스트에 스프링이 깊숙히 관여해야 한다.
    - 이 때문에 테스트 코드만 보고 테스트 내용을 파악하기 좀 더 어려워졌다. Bean 설정도 알아야 하기 때문이다.
  - XML 설정을 사용할 경우 자바 설정과 다르게 특이한 일들을 몇가지 할 수 있다.
    - parent 값으로 bean 설정을 상속받거나, static 클래스를 bean으로 등록할 수 있다.
    - Java 설정에서도 불가능한 건 아니지만 굳이 사용할 이유가 없어서 다른 방안으로 접근할 수 있다.
  - 포인트컷 표현식
    - 포인트컷을 매번 클래스명, 메서드명으로 복잡하게 설정하긴 너무 귀찮다.
    - AspectJ를 확장한 `AspectJ 포인트컷 표현식`을 이용하면 더 쉽게 프록시 적용 대상을 선별할 수 있다.
      - Regex를 사용할 수 있도록 도와준다.
    - 포인트컷 표현식 문법은 여러 방법으로 타깃 오브젝트를 지정할 수 있도록 도와준다.
      - execution(): 포인트컷 표현식 문법을 통해 타깃 오브젝트를 지정한다. (상세 문법에 대해서는 토비의 스프링 491페이지부터 참조)
      - annotation(): 특정 이름을 가진 어노테이션을 대상으로 지정한다.
      - bean(): 특정 Bean의 이름을 가진 오브젝트를 대상으로 지정한다.
    - 포인트컷 표현식은 코드와 설정이 매우 단순해지지만, 문자열 방식이기 때문에 런타임까지 오류를 발견하기가 매우 어렵다.
    - 그만큼 포인트컷 표현식을 사용하기 전에 철저한 검증을 거쳐야 한다.
      - 추가로 스프링에서 포인트컷 표현식 검증을 편하게 수행하기 위한 도구들이 제공된다.
    - 주의사항
      - 포인트컷 표현식 요소 중 `타입 패턴`이라 명시된 친구들은 말 그대로 `타입의 이름`을 비교한다.
      - 예를 들어, 표현식에서 클래스를 지정하는 경우 해당 클래스명이 아니라 `클래스 타입의 이름을 기준`으로 타깃 오브젝트를 선별한다.
      - 생으로 AspectJ 포인트컷을 테스트하고 싶다면 `Pointcut Weaver` 의존성을 추가해야 한다.
