## 3. 스프링 템플릿
- 코드는 크게 변경되려는 부분과 변경되지 않으려 하는 부분 두가지로 나뉜다.
- 템플릿은
    - `변경이 거의 일어나지 않고 일정한 패턴으로 유지되는 특성을 가진 부분`을 `변화가 자주 일어나는 부분`으로부터 분리한다.
    - 이 분리를 통해 효율성을 높이고 자유롭게 활용할 수 있다.

### 3.1 여전히 문제가 있는 DAO
- 기존에 구현하던 예제는 여전히 아주 큰 문제가 있다.
- 예외에 대한 처리가 이루어지지 않는다.
    - 자원을 제대로 반환하지 못해서 서버 환경에서 심각한 문제를 만들 수 있다.
- try-catch-finally를 통해 코드에서 리소스가 세는 일 없도록 잘 막아줘야 한다.
    - 이펙티브 자바에서는 closeable 인터페이스 구현과 try-with-resources를 권한다.
    - 여기서는 일단 예제 코드니까 간단하게 try-catch-finally를 사용한다.
- 이정도 예외 처리까지 되면 큰 무리는 없는 코드가 됐다.
- 하지만 여전히 문제가 있다.
    - 에러 발생 시점에 따라 어떤 자원을 닫을 것인지 명시가 필요하다.
    - 자원 반환까지도 예외가 발생할 수 있는 코드이기 때문에 자원 반환도 예외 처리를 해야 한다.
    - 무엇보다 반복이 너무 많이 된다 => 어딘가 반복을 해소하고 고칠 건수가 있을 것이다.
    
### 3.2 변하는 부분과 변하지 않는 부분
- 복붙으로 비슷한 코드를 나열하면 의도치 않게 굉장한 폭탄을 만들게 된다.
- 그렇다고 이런 예외 케이스를 모두 유닛 테스트로 만들기에는 테스트 비용이 너무 과도하게 크다.
- 결국 이런 문제를 해결하기 위해서는 변하지 않는 부분을 선별해서 잘 분리하는 작업이 필수적이다.
- 첫번째 방안: 메서드 추출
    - 이전처럼 공통되는 부분을 메서드로 추출해서 처리할 수 있다.
    - 문제는 추출된 메서드를 `다른 곳에서 재사용` 할 수 있어야 하는데, 이 경우는 반대다.
    - 현재 상황은 `분리시키고 남은 메서드`를 재활용 하고 싶은 상태
    - 이 부분이 바로 템플릿 패턴, 전략 패턴을 적용하기에 적합한 냄새
- 두번째 방안: 템플릿 메소드 패턴
    - 변하지 않는 부분을 슈퍼 클래스에 두고 변하는 부분을 추상 메서드로 제공하는 방안
    - 문제는 상속의 한계점을 고스란히 다 물려받게 된다.
        - 확장 구조가 이미 클래스를 설계할 때 고정된다(클래스 의존 = 런타임 의존)
        - 이로 인해 유연성이 매우 떨어지며 다중 상속이 불가능하기 때문에 하위 클래스는 다른 기능을 확장할 수 없다.
        - 또 매번 새로 클래스를 만드는 등 구현 자체가 매우 귀찮아진다.
- 세번째 방안: 전략 패턴
    - 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스에만 의존하도록 구현한다.
    - 오브젝트 구성
        - 컨텍스트 오브젝트: 변하지 않는 부분을 구현한 오브젝트
        - 전략 오브젝트: 인터페이스로 추상화 된 컨텍스트가 실행할 오브젝트
        - 전략 구현 오브젝트: 구체적으로 전략이 어떻게 동작할지 명시된 오브젝트
    - 물론 그냥 전략 패턴만 적용해서는 단점도 있다.
    - 전략 패턴을 올바르게 사용하고 싶다면 `클라이언트 코드의 책임`이 필수적이다.
    - 결국 리팩토링을 반복하면 DI에 가까운 형태로 변화한다.
- DI와 전략 패턴
    - 결국 DI는 전략 패턴을 좀 더 쉽게 널리 사용할 수 있도록 만들어진 구조다.
    - 가장 중요한 건 컨텍스트 코드를 클라이언트 코드에서 전략을 만드는 부분과 분리시켜야 한다.
    - 즉, 제 3자의 도움을 통해 오브젝트 간의 유연한 관계가 설정되도록 만들어야 한다.
    - DI의 구성요소
        - 의존관계에 있는 2개의 오브젝트
        - 관계를 다이나믹하게 설정해주는 오브젝트 팩토리(DI 컨테이너)
        - 이를 사용하는 클라이언트 오브젝트
    - 꼭 스프링에서만 사용하지 않는다. 또한 꼭 이렇게 네 가지 오브젝트가 명시적으로 존재하지 않을 수도 있다.
    - 이 책임을 한 오브젝트에서 메서드 단위로만 분리된 채로 클래스 내에 병합되어 있을 수도 있다.
        - 중요한 건 DI 구성요소와 같은 `네 가지의 책임`이 있다. (특히 클라이언트 오브젝트)
    - 위와 같이 한 클래스에서 여러가지 전략 패턴의 구성 요소의 책임을 수행하는 형태를 `마이크로 DI`라고도 한다.
    
### 3.3 전략 패턴의 최적화
- 여전히 마음에 들지 않는 부분이 존재한다.
    - 특히, DAO에 메서드가 추가될 때마다 늘어나는 클래스 파일들이 마음에 들지 않는다.
    - 이대로면 템플릿 메서드 패턴과 크게 다를 게 없다. (다이나믹 DI의 이점을 뺀다면)
- 개선 방안1: 로컬 클래스 활용
    - DAO의 각 메서드 내부에 전략 클래스를 구현하는 방법이 있다. (중첩 클래스)
    - 로컬 클래스는 자신이 선언된 곳의 정보에 접근 가능하기 때문에 불필요하게 User를 전달받는 문제를 해결할 수 있다.
    - 주의할 점은 `내부 클래스에서 외부 변수를 사용할 때는 반드시 final로 선언해줘야 한다.`
    - 참고사항: 중첩 클래스
        - 클래스 내부의 클래스를 지칭하는 용어
        - static 중첩 클래스: 독립적으로 오브젝트화 시킬 수 있다.
        - 내부 중첩 클래스: 선언된 클래스의 내부에서만 오브젝트화 시킬 수 있다.
- 개선 방안2: 익명 내부 클래스 활용
    - 사실상 DAO의 각 메서드에서 사용되는 클래스들은 이름도 필요 없다. (1회성이기 때문)
    - 익명 내부 클래스를 활용하면 아예 인자로 오브젝트화 된 클래스를 정의와 동시에 전달할 수 있기 때문에 생각해볼만 하다.
    - 최근에는 익명 내부 클래스보다 람다를 활용할 것을 추천한다.(이펙티브자바 Item45. 참고)
    - 이펙티브자바에서는 추가적으로 람다를 메서드 참조로 바꿀 것을 권하지만(Item46.) 현재 예제에서는 어렵다
        - 메서드 인터페이스가 Connection -> PreparedStatement로 잡혀있기 때문이다.
        - 각 메서드에서 부분적으로 User 오브젝트를 참고할 때도 있기 때문에 현재 예제에는 람다가 더 잘 어울린다.

### 3.4 컨텍스트와 DI
- JDBC 컨텍스트의 경우 다른 DAO에서도 공통으로 사용할 수 있기 때문에 클래스 분리를 해주는 게 바람직하다.
- 클래스를 직접 DI?
    - 스프링의 기본 원칙은 인터페이스 DI다.
    - 드문 경우 구체 클래스를 DI 하기도 한다.
        - 서비스 오브젝트들은 그 자체로 독립적인 컨텍스트를 제공하기 때문에 구체 클래스를 바로 DI해도 된다.(무슨 말일까..?)
        - 일단 앞서 잠깐 나온대로 `구현방법이 절대로 안바뀔 오브젝트`들은 `구체 클래스 DI`를 허용한다고 알아두자.
    - 그렇다고 이 방식이 DI가 아닌 건 아니다.
        - 스프링의 DI는 IoC 개념을 포괄하고 있다.
        - 구체 클래스를 DI 시켰어도 스프링 컨테이너가 여전히 두 오브젝트의 제어권한을 갖고 있는 IoC 형태를 띈다.
        - 즉, 넓게 봤을 때 구체 클래스끼리 긴밀하게 연결됐어도 DI라고 할 수 있다.
- 강한 결합을 가진 DI
    - 구체 클래스를 DI 하는 건 결합이 아주 강하다. 그럼에도 불구하고 DI를 하는 이유는 무엇인가?
        - 스프링의 싱글톤 레지스트리에서 싱글톤 빈으로 관리받을 수 있다.
        - JdbcContext가 스프링 빈에 의존하고 있기 때문에 무조건 사용해야 한다.(스프링 빈은 빈끼리만 의존관계를 맺을 수 있다.)
    - 귀찮다고 강한 결합을 가진 DI를 남발해서는 안된다. 최대한 느슨하게 연결해 놓고 마지막에 고려해라.
- 코드를 통해 수동으로 DI 시키기
    - datasource, userDao만 빈으로 등록하고 해당 빈을 수동으로 DI 시켜서 처리할 수 있다.
    - 대신 싱글톤으로 만드는 걸 포기해야 한다.
        - JdbcContext의 경우 내부 상태가 없기 때문에 이를 포기해도 큰 문제는 안된다.
        - 다만, 스프링 빈이 아니기 때문에 클라이언트 코드인 UserDao가 임시로 마이크로 DI를 수행해야 한다.
    - 상황에 맞게 적절하게 사용하면 된다.
    - 수동으로 DI 시키면 어색하게 빈으로 등록하지 않으면서도 다른 오브젝트에 대한 DI를 수행할 수 있다.
- 구체 클래스의 스프링 DI vs. 수동 DI
    - 스프링 DI의 경우 의존관계가 설정파일에 명확하게 드러나지만 구체 클래스 간 의존성이 직접적으로 노출된다.
    - 수동 DI의 경우 클래스간 의존성을 감출 수 있지만 싱글톤으로 만들수 없고 부가적인 코드가 필요하다.
    - 상황에 맞게 알아서 잘 선택해서 쓰자(명확한 이유가 없다면 그냥 인터페이스 DI 하는 게 안전하긴 하다)
    
### 3.5 템플릿과 콜백
- JdbcContext는 전략 패턴과 유사해보이지만 `템플릿/콜백 패턴`이라 불리는 특수한 디자인패턴으로 볼 수도 있다.
- 과거에는 람다가 없었기 때문에 콜백을 오브젝트로 전달했지만 Java8부터는 람다를 통해 메서드를 인자로 보낼 수 있다.
- 템플릿/콜백만의 특징
    - 보통 단일 메서드 인터페이스를 사용한다. (전략 패턴은 일반 인터페이스 구조일 확률이 높다.)
    - 대개 콜백 인터페이스에는 파라미터가 있고, 해당 파라미터에 템플릿의 컨텍스트 정보를 받아온다.
    - 여기서도 클라이언트 코드의 역할이 매우 중요하다. => `콜백을 만들고 전달한다.`
    - 메서드 레벨에서 DI가 일어나는 전략 패턴으로 봐도 무방하다.
    - 현재 구현한 JdbcContext는 리턴값이 없는 꾀나 단순한 템플릿/콜백 패턴이다.
- 콜백을 개선하자
    - UserDao가 많이 봐줄만해졌지만 여전히 한가지가 맘에 안든다.
    - 람다를 매번 작성해주는 게 아주 꼴 보기 싫다.
    - 변하지 않는 부분과 변하는 부분을 구분하고 변하지 않는 부분을 메서드로 추출해서 개선할 수 있다.
    - 이렇게 추출된 메서드는 사실 JdbcContext로 옮겨도 좋다.
        - 'JdbcContext에서 너무 많은 일을 하는 게 아닐까?' 싶을 수도 있다.
        - 하지만 이 경우 실제로 기능상 응집도가 높기 때문에 같은 클래스에 놓는 게 더 유지보수하기 좋다.
- 템플릿/콜백 패턴을 잘 활용하려면?
    - 스프링이 기본적으로 제공해주는 템플릿 콜백 패턴이 많다. 이 활용 방법을 충분히 숙지하자
    - 물론 절대 원리도 모르면서 기계적으로 따라하진 말자
    - 또한 필요하다면 직접 만들어서 활용도 할 수 있어야 한다.
    - 템플릿/콜백 활용 연습
        - 기본은 반복 제거 => 반복되는 코드가 있다면 우선 메서드 분리를 하자
        - 반복되는 코드의 일부 작업을 필요에 따라 변경해야 한다면 => 인터페이스, 전략패턴, DI를 활용해보자
        - 바뀌는 부분이 한 애플리케이션 안에서 동시에 여러 종류라면 => 템플릿/콜백 개선을 고려하자
- 중복 제거의 마지막 템플릿/콜백
    - 반복되는 코드가 세 번 이상 발생한다면, 지체없이 리팩토링을 할 때다
    - 메서드 추출, 전략 패턴을 사용한 뒤 추가로 템플릿/콜백 패턴 적용을 고민할 수 있다.
    - 템플릿/콜백 패턴 적용 시에는
        - 템플릿과 콜백의 경계를 잘 성정해야 한다.
        - 이를 위해서 `템플릿에서 콜백으로 줄 정보`와 `콜백에서 템플릿을 줄 정보`를 잘 구분해야 한다.
    - 핵심은 `코드의 특성이 바뀌는 경계`를 찾아내는 것
    - 바뀌는 부분과 바뀌지 않는 부분을 구분해서 인터페이스로 추출하면 자연스럽게 템플릿/콜백 패턴이 완성될 것이다.

### 3.6 JdbcTemplate
- 스프링이 자체적으로 제공하는 템플릿 패턴 첫번째
- JdbcTemplate은 스프링에서 제공하는 클래스지만 DI 컨테이너 없이 직접 주입해서도 사용 가능하다.
- 사실 지금까지 하던 짓은 스프링에서 아주 잘 만들어서 제공하는 기능이 있었다!
- JdbcTemplate.update
    - createdPreparedStatement 메서드를 통해 쿼리를 실행시킬 수 있다.
    - 그냥 바로 실행할 쿼리문을 인자로 전달해서 바로 실행시킬 수도 있다.
- JdbcTemplate.query
    - PreparedStatementCreator, ResultSetExtractor 콜백 두개를 인자로 전달해 실행할 수 있다.
    - ResultSetExtractor 대신 RowMapper을 넘겨줄 수도 있다.
    - 일반적으로 여러개의 결과가 반환될 때 사용한다.
    - queryForInt 등 ResultSet의 타입이 정해진 세부 메서드들도 있다.
- JdbcTemplate.queryForObject
    - PreparedStatementCreator, ResultSetExtractor(혹은 RowMapper) 콜백 두개를 인자로 전달해 실행할 수 있다.
    - 결과가 하나가 아닐때는 예외가 발생한다.
