## 5. 서비스 추상화
- 자바에는 사용방법과 형식이 다르지만 유사한 목적을 가진 기술이 존재한다.
- 상황에 따라 같은 목적의 기술을 여러 접근방법, API 사용 방식으로 사용한다면 매우 귀찮다.
- 스프링은 위처럼 목적이 같고 방법이 다른 기술들을 추상화하고 일관되게 다룰 수 있도록 도와준다.

### 5.1. Service 계층
- 일반적으로 비즈니스 로직의 흐름을 담당한다.
- DDD 개념을 적용하려면 Big Service를 경계할 필요가 있다.
    - 일단 예제에서는 적당히 넘어간다.
- if, else가 메서드 내에서 남발되는 건 책임이 과하다는 얘기와 같다. => 분리하자
- 모든 코드는 `의도가 드러나게` 만들자
- `숫자, 문자열` 등도 중복이 보인다면 `중복 제거`해야 한다.

### 5.2. 트랜잭션 서비스 추상화
- DB 작업이 막 일부만 실패하고 그러면 난리난다.
- 다 박살나거나 다 잘되거나
- 중간에 예외가 발생하는 등 테스트가 복잡할 때는 테스트용 대역을 구현하면 좋다
    - 밀접하게 연관되도 되기 때문에 편하게 상속 쓰면 좋다.
    - 어차피 테스트용으로만 쓰니까 클래스 안의 static 클래스로 만들어도 된다. 
- 트랜잭션의 경계
    - DB의 단일 SQL문은 트랜잭션을 완벽하게 보장한다.
    - 여러개일 때가 문제.
    - 여러개를 한개의 트랜잭션으로 설정해 줄 필요가 있다.
    - 묶인 상황에서 끝나는 방법은 두가지 뿐이다 -> commit(완전한 성공), rollback(완전한 실패)
- 트랜잭션의 경계설정
    - 일반적인 JDBC는 한개의 작업이 끝날 때마다 해당 작업을 commit 한다.
    - 트랜잭션 경계는 이 자동 commit을 끄고 한번에 동작할 SQL을 묶어서 처리한 뒤 commit이나 rollback 시키는 작업을 의미한다.
    - 이 트랜잭션은 Connection 객체에서 이루어진다.
    - 즉, 트랜잭션은 Connection이 열려 있는 동안만 작동하며, 이 때문에 `로컬 트랜잭션`이라고도 부른다.
- UserService가 DB 작업을 UserDao에만 전적으로 의존하면 이런 트랜잭션 경계를 설정하기가 매우 어렵다
    - UserService에서는 DB Connection을 제어할 방법이 없기 때문이다.
- 그렇다면 UserService에서 Connection을 생성하고 트랜잭션만 제어하면 어떨까?
    - 가능은 하다 대신 Connection 객체를 인자로 메서드를 호출할 때마다 전달하는 불편함이 생긴다.
        - 스레드 문제 때문에 Connection을 인스턴스 변수로 만들 수도 없다.
    - JDBCTemplate을 이용할 수 없다. 다시 JDBC Context 시절로 돌아가야 한다.
    - 이렇게 되면 UserDao가 특정 기술(JDBC)에 종속된다.
    - 테스트 코드도 줄줄이 터져나가기 때문에 변경해야 될 게 많다.
- 트랜잭션 동기화
    - 문제를 해결하기 위해 스프링이 제시하는 방식은 트랜잭션 동기화다
    - 서비스 계층에서 작업을 시작할 때 Connection 객체를 생성해서 트랜잭션 저장소로 넘기고 해당 Connection 기반으로 트랜잭션 경계를 설정한다.
    - DAO는 트랜잭션 저장소를 통해 DB 작업을 수행한다.
    - 트랜잭션 저장소는 작업 스레드 별로 분리되기 때문에 다중 스레드 환경에서도 안전하다.
- 트랜잭션 동기화 적용
    - TransactionSynchronizationManager를 통해 스프링이 제공하는 트랜잭션 동기화 관리 클래스를 불러올 수 있다.
    - 트랜잭션 동기화 시 Connection은 DataSourceUtils를 통해 불러오는 게 좋다.(알아서 트랜잭션 저장소에 동기화까지 해준다.)
    - 트랜잭션 동기화가 된 상태로 JDBCTemplate을 사용하면 JDBCTemplate은 작업 중 동기화된 DB Connection을 사용한다.
- JDBCTemplate은 어떻게 동기화가 된거지?
    - 스프링이 알아서 똑똑하게 잘 처리해준다.
    - JDBCTemplate은 실행되기 전 트랜잭션 동기화 저장소를 확인하고 저장소에 Connection이 없는 경우에만 직접 Connection을 생성한다.
    - try/catch/finally 작업 흐름 지원, SQLException 예외 변환, 트랜잭션 동기화 Connection 지원 이 세가지가 JDBCTemplate의 주요 기능이다.
- 개선된 트랜잭션 처리 방식은 또하나의 문제가 발생한다: `구현기술에 종속`된 코드가 만들어진다.
    - 여러개의 DB, 메시지 큐와 작업을 해야할 경우 JTA를 사용해야 하며, 기존과는 다른 방식으로 트랜잭션을 관리한다.
    - DAO를 하이버네이트로 전환해도 마찬가지다. 하이버네이트는 세션이라는 객체를 통해 트랜잭션을 관리한다.
- 이를 해결하기 위해 `트랜잭션 처리를 추상화` 할 방법을 고민할 필요가 있다.
    - 트랜잭션 처리는 각 기술별로 구현은 다르지만 대체로 유사한 형태를 갖기 때문에 이게 가능하다.
- 스프링에서는 `트랜잭션 처리에 대한 추상화`로 추상 `인터페이스`인 `PlatformTransactionManager`를 지원한다.
    - JDBC의 경우 DataSourceTransactionManager 구현체를 통해 사용할 수 있다.
    - getTransaction을 통해 트랜잭션만 가져오면 필요에 따라 DB Connection도 같이 가져온다.
    - 시작된 트랜잭션은 TransactionStatus 타입의 변수에 저장된다.
    - 이 변수를 트랜잭션 관련 작업(commit, rollback) 시 전달해줘야 한다.
    - PlatformTransactionManager는 트랜잭션 동기화 저장소를 이용하기 때문에 JDBC에 별도로 Connection을 넘겨주지 않아도 된다.
- 스프링이 제공하는 PlatformTransactionManager의 구현체는 모두 Thread-safe 하다.
    - 맘 놓고 스프링 빈으로 등록해도 된다는 의미다.
    - 또한 빈으로 등록하지 않으면 서비스 계층에서 트랜잭션 매니저의 구현에 의존하기 때문에 빈으로 등록하고 DI 해주는 게 좋다.
- 예제에서 알 수 있듯 추상화는 `기술`, `서비스` 양쪽 모두에 적용 가능하다.
    - 이 추상화를 통해 서로 다른 관심사를 독립시킨 깔끔한 코드를 만들 수 있다.
    - 이 모든 깔끔한 추상화의 이점은 DI를 통해 이뤄진다.
    - DI의 핵심가치는 관심, 책임, 성격이 다른 코드를 깔끔하게 분리하는 데 있다고 할 수 있다.
- 단일 책임 원칙
    - `하나의 모듈이 변경되는 이유는 오직 하나여야 한다`는 모두가 알지만 지키기 어려운 규칙
    - 단일 책임 원칙이 깨지면 1개의 변경사항에 대해 변경 대상이 모호하거나 여러개가 되기 때문에 인적 실수가 발생할 확률이 높다.
    - 이 원칙을 지키기 위한 가장 좋은 도구는 DI다.
    - DI가 없다면 인터페이스를 통해 단일 책임 원칙을 지키려 했다 하더라도 코드 간 결합이 남게 된다.
    - 단일 책임 원칙을 지키기 위해 DI를 어떻게 활용할 것인지 잘 생각하고 고민하며 학습을 진행하자.

### 5.3. 메일 서비스 추상화

