# 1장. 오브젝트와 의존관계
## 1.1. 쓰래기 DAO 구현해보기
- 객체지향 안티패턴의 결정체라 할 수 있는 TrashUserDao를 구현하고 개선해보자
- 중요한 건 여기서 던질 질문들이다.
    - 기능 잘 동작하는 이 코드가 도대체 무슨 문제가 있을까?
    - 잘 동작하는 코드를 굳이 왜 고쳐야 할까?
    - 개선했을 때 있는 장점은 무엇인가?
    - 이 장점은 지금 당장 효과가 있나? 이후에도 좋은가?
    - 객체지향 설계 원칙은 또 이거랑 뭔 상관인가?
    - 스프링을 사용하는 관점에서 이 개선안은 어떤 의미가 있는가?
- 그냥 따라 치는 게 아니라 이런 의문에 관심을 기울이고 개선하는 것이 가장 중요하다.

### 1.2. 쓰래기 DAO를 개선하자
- 소프트웨어의 변화
    - 모든 소프트웨어는 변화한다.
    - 끝이란 없다. 폐기하는 날이 끝나는 날이다.
    - 변화에 대비해야 하는 이유
        - 소프트웨어는 늘 변하기 때문에 변화에 대비하는 코드를 만드는 게 중요하다.
        - 그래야 효율적으로 개발할 수 있다.
        
- 객체지향 설계의 가치
    - 일반적으로 실세계를 최대한 가깝게 모델링할 수 있는 걸 객체지향의 가치로 여김
    - 실제로는 객체지향 기술이 만들어내는 `가상의 추상세계` 자체에 있다.
    - 객체지향의 `추상세계`는 자유롭고 편리하게 변경, 발전, 확장 시키는 데 큰 도움을 준다.
        - ArrayList 같은 건 실제 세계에 존재하지 않는다.
        - 하지만 객체지향에서는 존재할 수 있는 추상 개념이며, 개발자들이 자바 컬렉션을 다루는 데 아주 큰 도움을 준다. 

- 변화에 대응하는 우리의 자세
    - 변화의 폭 자체를 줄여주면 된다.
        - 변화가 발생했을 때 우리 코드가 영향 받는 부분을 최소화시키면 된다
    - 분리와 확장을 고려한 설계가 필요하다!

- 분리를 고려한 설계
    - 모든 변경과 발전은 한 번에 한가지 관심사항에 집중해서 일어난다.
        - 여러군데 산발적으로 일어나는 건 요구사항 정리 차원에서 걸러줘야 한다.
    - 그러므로 변경이 발생했을 때 우리의 코드도 그 변경 관심사항에 맞게 한군데서 변화가 일어나면 대응하기 쉽다.
    - 즉, 관심사가 비슷한 오브젝트끼리 모아서 관리하면 유연한 설계를 할 수 있다.

- 쓰래기 DAO의 관심사항
    - 현재 최소 세가지의 관심사항이 있다.
        - 어떻게 DB 연결을 할 것인가
        - 어떻게 SQL을 만들고 실행할 것인가.
        - 어떻게 다 쓴 공유 자원을 반환할 것인가.
    - 이 외 더 세부적인 관심사가 있지만 일단 패스
    
- 중복된 코드를 제거하자
    - `메서드 추출`을 통해 `DB 연결`이라는 관심사를 분리할 수 있다.
    - 이렇게 분리를 통해 앞으로 추가될 기능들이 DB 연결에는 신경쓰지 않아도 된다.
    - 중복 코드는 아주 강력한 리팩토링 대상이다. 냄새를 잘 맡자.
    - 리팩토링
        - 현재 기능을 변경하지 않고 내부 구조를 개선하는 작업, 기술
        - 자동화 된 테스트가 필수다. 이거 없으면 코드를 변경하고 이게 잘 동작하는지 확신을 가질 방법이 없다.
        - 이런 관점으로 볼 때 trashDaoV1 패키지는 테스트 코드까지 쓰래기다.(단순 main 클래스)
        - 매번 테스트 실행 전에 DB를 확인하고 테스트 데이터와 중복되는 데이터가 있으면 삭제하고 다시 실행하는 수동적인 방법이 필요하다. 

- 메서드 추출 대신 상속을 사용해보자
    - 메서드 추출은 아주 기초적인 관심사 분리다.
    - DB 커넥션을 각기 다른 의도로 완전히 다른 방식으로 생성하고 싶다면 메서드 분리로는 부족하다.
    - 상속과 디자인 패턴을 잘 이용하면 이 부분을 해결할 수 있다.
    
- 템플릿 메서드 패턴을 사용해보자
    - 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메서드나 오버라이드 가능한 메서드로 만든 뒤 서브 클래스에 제공하는 방식
    - 스프링이 애용하는 디자인 패턴 중 하나다.
    - 이를 통해 UserDao를 확장한 서브 클래스들이 원하는 방식으로 자유롭게 DB 커넥션을 생성할 수 있다.
    
- 팩토리 메서드 패턴을 사용해보자
    - UserDao 슈퍼 클래스는 Connection 인터페이스를 준수하는 오브젝트라면 무엇이든 사용 가능하다.
    - 어떤 Connection이 오는지 슈퍼 클래스는 관심 없다.
    - `확장한 서브 클래스에서 어떤 오브젝트를 줄지 오브젝트 생성 방법을 결정하는 것`을 팩토리 메서드 패턴이라 한다.
    - 자바에서 오브젝트를 생성하는 기능을 가진 메서드를 부르는 팩토리와 팩토리 메서드 패턴의 팩토리는 의미가 다르다.
    
- 하지만 상속은 좋지 못하다
    - 이펙티브자바에서도 설명하듯 상속은 캡슐화를 깨는 좋지 않은 패턴이다.
    - 슈퍼 클래스 변경 사항이 하부 클래스에 엄청 큰 영향을 끼치기 때문에 결합도가 너무 높다.
    - 또 이 클래스 외에 다른 DAO 클래스로 공통적으로 사용하는 기능을 줄 수 없는 제약사항이 존재한다.

### 1.3. DAO를 확장해보자 (추상화를 적극적으로 쓰자)
- 관심사가 다르다는 건 변화의 성격도 다르다는 의미다.
- 변화의 성격이 다르다는 건 변화의 `이유`, `시기`, `주기`가 다르다는 의미다.
- 즉, 관심사를 분리하면 각기 다른 이유, 시기, 주기에 따라 수정할 수 있기 때문에 복잡하게 엉킨 코드를 만질 일이 줄어든다.
- 상속을 통해서도 이 문제를 해결할 수 있지만, 상속은 문제가 많다.(이펙티브자바 참고)

- 클래스 자체를 뜯어내자
    - 상속 관계가 아니라 DAO와 DB Connection 생성하는 ConnectionMaker 클래스를 아예 별도로 분리해버리자
    - 그리고 DAO에서 ConnectionMaker 클래스의 인스턴스를 생성해서 사용하면 만사가 깔끔해진다.
    
- 추상화 시키자
    - 문제는 위처럼 클래스 자체를 분리하고 사용하도록 만들어주면 DAO가 ConnectionMaker에 종속된다.
    - 두가지 문제점이 있다.
        - DAO는 ConnectionMaker의 `메서드 중 무엇을 사용할건지 구체적으로` 알고 있어야 한다.
        - DAO는 정확히 `어떤 ConnectionMaker를 사용할지 구체적으로` 알고 있어야 한다.
    - 그놈의 구체적인 게 문제다. 구체적으로 알아야 한다는 건 아주 자세히 세세하게 알고 있어야 한다는 의미다.
    - 두 클래스 사이의 추상화 계층(인터페이스)를 넣는다면 이런 문제를 해결할 수 있다.
        - 두리뭉실하지만 어떤 메서드를 써야하는지, 구현해야하는지 알려줄 수 있다.
        - 인터페이스를 구현한다면 어떤 오브젝트가 오건 DAO는 문제없이 사용할 수 있다.
        
- 그래도 여전히 구체적이다.
    - 문제는 위와 같이 인터페이스만 도입해서 완전히 해결할 수 없다.
    - 여전히 DAO 안에서 ConnectionMaker 오브젝트를 생성할 때 어떤 오브젝트를 생성할지 알고 있어야 한다.
    - `어떤 구현 클래스의 오브젝트를 이용할지 결정`하는 건 이미 굉장히 구체적인 관심사항이다.
    
- 오브젝트 간 구성관계는 별도의 관심사다.
    - 어떤 구현 클래스의 오브젝트를 이용할지 결정하는 것은 이미 별도의 아주 중요한 보통은 숨어있는 책임이다.
    - 책임이 다르다는 건 관심사가 다르다는 것. => 분리 대상
    - 이를 `런타임 사용관계, 링크, 의존관계`라 부른다.
    - 클래스 내부에서 구체적으로 다른 클래스의 이름이 드러난다는 건 위 책임이 숨어있다는 냄새일 수 있으니 잘 맡아야 한다.
    
- 관심사가 다르니 분리하자
    - 오브젝트 간 런타임 사용관계를 관심사로 규정 지었으니 이걸 누군가가 책임지고 수행해야 한다.
    - 최적의 대상은 `클라이언트 코드`다.
        - 보통 레이어드 아키텍처에서는 서비스 레이어가 런타임 사용관계 규정과 트랜잭션 경계 설정을 주책임으로 가져간다.
        - TDD를 사용한다면 테스트 코드가 최초의 클라이언트 코드로써 책임이 올바르게 분배되고 있는지 확인할 수 있다.
            - 좋은 설계를 위한 지뢰탐지기 역할을 수행한다.
    - 구체적으로 뭘 넣을지 결정하는 건 결국 사용할 때다.
    - 그러므로 클라이언트 코드가 어떤 오브젝트를 넣을지 결정해서 사용할 코드에 밀어넣는 건 당연한 일이다.
    
- 좀 더 유연한 코드
    - 상속보다 짤 코드가 많아지긴 했다.
    - 그래도 상속보다 훨씬 재사용성이 높고 느슨하게 연결된 유지보수성이 높은 코드를 만들 수 있다.
    - 주의점은 `인터페이스와 클라이언트 코드의 협력`이다.
    - 인터페이스로 느슨하게만 만든다고 끝이 아니다. 결합해서 완전히 뜯어낼 수 있도록 코드 냄새를 잘 맡자.

- 개방 폐쇄 원칙
    - SOLID의 두번째 원칙으로 `확장에는 열려 있고, 변경에는 닫혀 있어야 한다`는 객체지향 원칙
    - 개선된 UserDAO는 DB 연결 방식을 확장할 수 있고, DB 연결 방식을 확장해도 DAO의 기능에는 영향이 없으므로 이 원칙을 잘 따른다 볼 수 있다.
    
- 높은 응집도와 낮은 결합도
    - 좀 더 고전적인 소프트웨어 원리의 관점에서 봐도 UserDAO 구조는 잘 들어맞는다.
    - 높은 응집도
        - 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다
        - 변화가 일어날 때 모듈 내에서 어딘가를 고쳐야 된다면, 변경 부분을 찾아서 고치고 다른 기능도 검증해야 하는 등 매우 번거롭다.
        - 반면 응집도가 높은 코드의 경우 변경은 항상 전체적으로 일어나고 무엇을 변경할지 아주 명확하다.
    - 낮은 결합도
        - 책임과 관심사가 다른 오브젝트 혹은 모듈은 느슨하게 연결된 형태를 유지해야 한다.
        - 캡슐화를 위해 서로 최소한만 알고 구현의 구체적인 사항은 알 필요도 없게 만들어주자.
        
- 전략 패턴
    - 개방 폐쇄 원칙과 높은 응집도 낮은 결합도를 취한 현재 UserDAO의 모습은 전략 패턴이라고도 부른다.
    - 필요에 따라 변경이 필요한 알고리즘(기능)을 통째로 외부로 분리시키고 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 변경하는 패턴이다.
        - 현재 DB를 연결하는 기능을 인터페이스를 통해 아예 외부로 분리시켰고, 클라이언트 코드가 어떻게 DB에 연결할지 결정한다.
        
- 그래서 스프링은?
    - 장황하게 설명한 이 장점들을 편리하게 구현할 수 있도록 도와주는 게 스프링이다.

### 1.4. IoC(제어의 역전)
- 얼렁뚱땅 넘어간 책임
    - UserDaoTest는 UserDao가 사용할 DB커넥션을 생성하는 책임을 얼떨결에 넘겨 받았다.
    - UserDaoTest의 관심사는 오브젝트를 `사용`하는 것인데, 어떻게 `생성` 할 지에 대해서도 관심을 강제로 갖게 됐다.
    - 관심사가 다르기 때문에 이 부분 역시 당연히 분리해줘야 한다.
    
- 팩토리
    - 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것
        - 팩토리 메서드 패의 팩토리와는 완전히 다르디. 주의하자.
    - 어떻게 만들지에 대해서만 관심이 있다. 만들어진 오브젝트가 언제 어디서 사용되는지는 아예 관심 없다.
    - 어플리케이션의 오브젝트를 구성하고 그 관계를 정의하는 책임을 맡는다.
    - 일종의 설계도(어떤 오브젝트가 어떤 오브젝트를 사용하는지 알려준다.)
    - 이를 통해 어플리케이션의 컴포넌트 역할을 하는 오브젝트와 구조를 결정하는 오브젝트를 분리해냈다.
        - 컴포넌트: 어플리케이션에서 실제 로직을 동작시키는 부분
        
- 계속해서 늘어나는 UserDao
    - UserDao가 계속 늘어나면 DaoFactory는 새로운 고민이 하나 생긴다.
    - ConnectionMaker를 매번 모든 Dao 생성자에 넣어줘야 한다.
    - 중복은 분리하는 게 최고다 -> 여기선 메서드 분리 정도만 해놓는다. 

- 그래서 제어의 역전은 무엇인가
    - 일반적인 프로그램은 모든 종류의 작업을 사용하는 쪽(오브젝트)에서 제어하는 구조다.
    - 제어의 역전은 말 그대로 이걸 까뒤집는다.
    - 각 오브젝트들은 사용할 오브젝트를 선택하지도 않고 생성하지도 않는다.
    - 심지어 각 오브젝트는 자기가 어디서 사용되는지도 모른다.
    - 모든 오브젝트는 제어권한을 위임받은 특별한 오브젝트에 의해서만 움직인다.
    - 템플릿 메서드 패턴, JSP 서블릿 등 이런 방식은 생각보다 흔하게 찾아볼 수 있다.
    - 이런 면에서 볼 때 DaoFactory도 IoC가 적용된 구현체다.
        - DaoFactory만 UserDao와 ConnectionMaker를 만들고 어떻게 연결할지 관계를 결정짓는다.
    - 프레임워크는 이 IoC를 적극적으로 활용하는 방법이다.
        - 라이브러리와 가장 큰 차이점이다. 라이브러리는 사용자가 개발을 주도하고 필요한 때 라이브러리 코드를 갖다 쓴다.
        - 프레임워크는 반대로 프레임워크가 개발을 주도하고 필요한 때 사용자가 만든 코드를 갖다 쓴다.

### 1.5. 스프링의 IoC
- 빈(Bean)
    - 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트
    - IoC가 적용되어 있다.
    
- 애플리케이션 컨텍스트
    - 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트
    - `빈 팩토리`라고도 부른다.
    - 직접 설정 정보를 담고 있진 않다.
    - 별도로 설정 정보를 갖고 있는 무언가를 가져와서 이를 활용하는 범용적인 IoC 엔진.

- 설정 구성
    - 애플리케이션 컨텍스트가 사용할 설정을 만드는 법은 여러가지가 있다.
    - XML, 자바 어노테이션 등등
    - 어노테이션을 쓸 경우 @Configuration, @Bean을 사용하면 된다.
        - Spring Boot의 @SpringBootApplication 어노테이션은 기본적으로 @Configuration 어노테이션을 포함하고 있다.
    - 오브젝트를 생성하는 메서드의 이름이 곧 Bean 이름이 된다.
    - ApplicationContext에서 getBean 메서드를 통해 Bean을 불러 올 수 있다.
    - Bean에 굳이 이름을 짓는 이유는 해당 오브젝트 생성, 구성 방식을 다양하게 갖고 갈 경우 겹치지 않도록 서로 다른 이름으로 부르기 위해서다.
    - 뭔가 더 귀찮아진 느낌이 들지만, 이 간단한 설정을 통해 스프링에서 사용할 무수히 많은 기능들을 활용할 수 있다.

- 스프링 IoC의 장점
    - 클라이언트는 구체적인 팩토리 클래스를 알 필요 없다.
        - 그냥 필요한 오브젝트를 갖고 와서 쓰기만 하면 된다.
    - 오브젝트 생성, 관계 설정 외의 많은 서비스를 제공한다.
        - 자동생성, 생성 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅
    - 다양한 검색방식
        - 빈이 덕지덕지 등록되면 점점 찾기 어려워진다.
        - 이를 좀 더 수월하게 찾도록 다양한 빈 검색 방식을 제공한다.

### 1.6. 싱글톤 레지스트리와 오브젝트 스코프
- 스프링 컨테이너는 IoC 컨테이너인 동시에 싱글톤 레지스트리의 역할도 수행한다.
- 즉, 스프링 Bean은 어플리케이션 상에서 각각 하나씩만 존재한다.
- 왜 싱글톤을 쓰는가?
    - 스프링의 주사용처는 엔터프라이즈 환경이다.
    - 엔터프라이 환경은 다음과 같은 특징을 지닌다.
        - 성능이 높아야 한다.
        - 대부분 계층형 구조다
        - 비즈니스 로직이 복잡하다.
    - 이런 환경에서 매 요청마다 객체를 계속 새로 만들면 아주아주 힘들어질 수 있다.
    - 이를 방지하기 위해 스프링은 기본적으로 Bean을 싱글톤으로 생성하도록 설계됐다.
- 디자인 패턴의 싱글톤?
    - 디자인 패턴의 싱글톤 패턴과는 아주 다르다.
    - 디자인 패턴의 싱글톤은 다음과 같은 문제가 있다.
        - 생성자가 private으로 제한되기 때문에 객체지향적인 설계를 적용하기 매우 어렵다.
        - 테스트하기가 매우 어렵다.(위의 이유로 다른 오브젝트로 대체하기가 아주 어렵다.)
        - 말만 싱글톤이고 여러개가 만들어질 수도 있다.(JVM 환경에 따라)
        - 싱글톤을 사용하다 보면 전역 상태를 형성할 확률이 매우 높다.
    - 안티 패턴이라는 얘기를 들을 정도로 사용에 주의를 요하는 패턴이다.
- 싱글톤 레지스트리
    - 성능은 높여야겠고, 싱글톤 문제는 해결하고 싶고 => 스프링이 해줄게!
    - 일반 자바 오브젝트를 싱글톤처럼 사용하도록 스프링 컨테이너가 알아서 관리해준다.
    - 싱글톤 오브젝트면서 객체지향 설계의 장점을 적용한 오브젝트를 만들도록 도와준다.
