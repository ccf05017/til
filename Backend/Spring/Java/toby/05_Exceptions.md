## 4. 예외
- 더럽게 귀찮지만 반드시 해야한다. 또한, 잘 처리해야 한다.

### 4.1 SQLException은 어디로 갔나
- JdbcTemplate을 적용하면서 슬쩍 사라진 예외들을 베스트 프랙티스로 복구해보자
- 안좋은 예외 처리
    - try/catch 문으로 감싸고 도망가는 경우
    - catch로 잡은 뒤 스택 트레이스만 찍거나 콘솔 로그만 남기는 경우
    - throw Exception 구문을 남발해서 모든 에러가 위로 가도록 만드는 경우
    - 위와 같은 예외 케이스는 `연습`에서라도 만들지 말아라. => 버릇들면 큰일난다
- 예외와 에러의 종류
    - Error
        - 어플리케이션에서 백날 잡으려 해도 못 잡는다.
        - JVM 자체에서 발생하는 문제 상황들이다. (OutOfMemory, ThreadDeath 등)
    - Check Exception
        - Runtime Exception을 상속받지 않은 예외들
        - 명시적으로 처리를 하거나, 상위 레벨로 던져줘야 한다.
    - Uncheck Exception(런타임 에러)
        - 명시적으로 처리하지 않아도 되는 예외들
        - 개발자의 부주의로 인해 발생하는 에러들을 지칭한다.
    - 최근에는 체크 예외를 굳이 써야 되냐는 주장이 많이 나오고 있다.
- 예외처리 방법
    - 예외 복구
        - 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 방안
        - 복구할 가능성이 있는 예외들에 대해서 선택할만 하다.
    - 예외 회피
        - 직접 처리하지 않고 호출한 오브젝트에 예외 책임을 전가시키는 방안
        - 단, 보내는 의도가 분명해야 한다.
        - 콜백/템플릿 처럼 긴밀한 관계가 있는 오브젝트에 던지거나, 호출한 쪽에서 처리하는 게 최신이라는 `확신`이 있을때만 사용하는 게 좋다.
    - 예외 전환
        - 발생한 예외를 맥락에 맞는 예외로 바꿔서 던진다.
        - 좀 더 `분명한 의미`를 가진 예외로 바꿔주기 위해 사용한다.
        - 전환할 때는 `중첩 예외` 형태로 만드는 것이 좋다.
        - 보통 체크 에러를 언체크 에러로 전환시킬 때 많이 사용한다.
        - 어차피 처리하지 못할 예외라면 에러 사실을 기록하고, 사용자에게 해당 에러에 대해 친절하게 안내하는 편이 더 낫기 때문이다.
- 최근의 에러처리
    - 언체크 에러 처리를 기본으로 가져간다.
    - 체크 에러 처리는 애플리케이션 개발을 과하게 귀찮고 번거롭게 만든다.
    - 자바 출시 초기에는 체크 에러를 통해 에러가 발생해도 복구하고 시스템이 멈추지 않도록 구현해야 했다.
    - 서버 환경에서는 어차피 처리 못할 에러가 많기 때문에 기본적으로 런타임 에러를 던지고 시스템 관리자에게 공지하는 전략을 기본으로 취한다.
- 애플리케이션 예외
    - 애플리케이션 로직 상에서 의도적으로 예외를 발생시키는 경우
    - 정상적인 로직과 비정상적인 로직 둘의 리턴값을 다르게 줘서 처리할 수도 있다.
    - 하지만 바람직한 방법은 비즈니스 로직에 맞는 예외를 `체크 에러`로 던져주는 것이다.
    
### 4.2 예외 전환
- JdbcTemplate은 몇가지 문제점이 있다.
- 비표준 SQL
    - SQL이 DB 별로 다르기 때문에 통일된 기능을 제공하기 어렵다.
    - 이를 해결하기 위해 `표준 SQL만 사용하기`, `DB 별로 DAO 만들기`, `SQL을 외부에 독립시키기` 셋 중 하나의 방법을 쓸 수 있다.
    - 권장되는 건 `DB 별로 DAO 만들기`, `SQL을 외부에 독립시키기` 두 개다.
- 호환성 없는 SQLException 에러정보
    - SQL 뿐 아니라 에러조차 벤더별로 다 다르다.
    - 아주 화가 나게 만들어준다.
    - 에러 코드 관련 표준이 있지만 벤더들이 표준을 잘 지키지 않는다.
- 위와 같은 현상들은 기술 독립적인 DAO를 만드는 데 어려움을 일으킨다.
- 에러 처리를 위해 DAO를 사용하는 클라이언트 코드가 해당 DAO 구현체의 기술에 종속되기 때문이다.
    - 단순히 인터페이스 분리를 하더라도 이 부분은 해결할 수 없다.
- 이를 방지하기 위해 Spring은 `DataAccessException`을 통해 계층적인 에러 체계를 제공한다.
    - 이를 통해 DAO의 구현 기술에서 벗어난 공통된 에러 처리 체계를 가져갈 수 있다.
    - 이는 JPA 등의 ORM에도 공통적으로 사용 가능하다.
    - 대표적인 예로 ORM에만 있는 낙관적인 락킹의 예외를 JdbcTemplate에서 낙관적인 락킹을 구현하고 사용할 때 발생시킬 수 있다.
- 그렇다고 DataAccessException이 완벽하게 모든 에러를 포괄할 수는 없다.
    - 근본적으로 한계가 있다. 각각의 구현 기술은 그 기술만의 관심사가 있고, 이를 모두 통합한 에러 체계를 만들 순 없다.
    - 그러므로 스프링의 계층화된 공통 에러를 사용한다 하더라도 `학습 테스트`를 통해 `꼭 어떤 문제가 발생할 수 있는지 확인` 해야 한다.
