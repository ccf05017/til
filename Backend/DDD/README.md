# IDDD 맥락 정리
## 무기력증?
### 1. 왜 생기나?
- 최대한 간단하게 표현된 예제들을 정제 없이 복사하면서 생김
- 기존 관습이나 패러다임(비주얼 베이직 등)의 잔재

### 2. 이게 왜 문제인가?
- 내가 짠 코드 이틀만 지나도 모르는 경우 이 무기력증 때문일 확률이 높다.
- 내가 만든 코드가 어떤 비즈니스 맥락에서 어떤 용도로 작성됐는지 명확하지 않다.
- 아래의 예시 코드는 굉장히 모호하고 범용적으로 사용할 수 있을 것처럼 생겼다.
- 하지만 어떤 비즈니스 환경에서 사용된건지 알 수 있을까?
- 또한 도메인 전문가가 이 코드를 보고 이해 할 수 있을까?
```java
// 의도가 전혀 보이지 않는 코드
public void saveCustomer(
    String customerId,
    String customerFirstName,
    ...
) {
    customer.setCustomerId(customerId);
    customer.setCustomerName(customerName);

    customerDao.save(customer);
}
```

### 3. 어떻게 해결하나?
- 당연하게도 책 제목처럼 DDD를 도입해봐라
- '바운디드 컨텍스트', '유비쿼터스 언어' 이 두 축으로 실질적인 해결책을 낼 수 있다.

## 유비쿼터스 언어
### 1. 정의
- 도메인 전문가와 소프트웨어 개발자 모두에 의해 '개발'되어 '공유'된 언어
- 도메인 전문가만의 언어도 아니고, 소프트웨어 전문가만의 언어도 아니다.
- 출발은 도메인 전문가가 사용하는 언어로 출발하지만 점진적으로 애자일하게 변화하며 진화한다.
- 바운디드 컨텍스트 하나당 하나의 유비쿼터스 언어가 존재하도록 개발해야 한다.

### 2. 어떻게 만드나?
- 일단 그림 그리고 이름을 붙여 봐라
- 간단한 용어로 만들어진 정의를 세워 봐라
- 하지만 위의 두가지는 시스템과 일치하지 않는 순간 내다 버려라
- 다시 현 상황에 맞는 새로운 언어로 진화시켜라
- 설계는 코드에 반영되야 한다. 종이 쪼가리나 그림이 아니라

### 3. 이점?
- 정교하고 유용한 비즈니스 모델을 얻을 수 있다.
- 비즈니스 모델을 평가할 객관적인 지표를 얻어낼 수 있다.
- 비즈니스를 보다 명확하게 이해할 수 있다.
- 도메인 전문가가 소프트웨어 설계에 기여하여 팀원 간 보다 나은 통합을 이룰 수 있다.
- 보다 나은 사용자 경험을 제공할 수 있다.
- 모델 주변에 명확한 경계를 만들 수 있다.
- 더 나은 설계, 구성을 얻을 수 있다.
- 애자일하게 움직일 수 있다.
- 전략, 전술 도구를 한방에 얻을 수 있다.

## 도메인

## 서브도메인

## 바운디드 컨텍스트
### 1. 정의
- 도메인 모델이 존재하는 명시적 경계
- 보통 언어적 경계를 이룬다.
- DDD에서는 컨텍스트가 왕이다.

### 2. 구현 방안
- 비슷하게 생긴 모델에 대해 각 컨텍스트 별 미묘한 차이를 파악하기 위해 노력해라.
- 다수의 컨텍스트에서 정확하게 같은 객체가 보인다면 이는 모델링 오류일 확률이 높다.

### 3. 주의사항
- 모든 것을 포괄하는 모델을 만드려 시도하지 마라.
- 대부분의 경우 이런 모델을 만드는 것 자체가 불가능하다.
- 이 때 바운디드 컨텍스트를 통해 문맥을 나누고 그 문맥 안에서 유효한 유비쿼터스 언어를 정의해라.

### 4. 예시1(같은말 다른뜻)
- 은행과 소설 둘 다 '어카운트'라는 명칭을 사용한다.
- 하지만 은행 컨텍스트의 '어카운트'는 해당 고객의 현재 은행 재무 상태를 나타내는 직불과 신용 거래 내역을 의미한다.
- 전혀 다르게 소설 컨텍스트의' 어카운트'는 하나 이상의 연관된 사건을 시간에 따라 문학적으로 표현한 집합을 의미한다.
- 위의 두 의미가 정확하냐 아니냐가 중요한 게 아니라 서로 다른 바운디드 컨텍스트에서는 같은 용어라도 전혀 다른 의미로 사용될 수 있다는 걸 알아라. 

### 5. 예시2(단계적 모델)
- 책을 출판하는 과정은 보통 7단계 정도로 구분된다.
- 각 단계별로 같은 의미의 통합된 책 모델을 사용하고 싶겠지만, 이게 가장 흔히 저지르는 실수다.
- 각 단계별로 책의 모델은 미묘한 차이를 지니며, 같은 책 모델 식별자를 공유하며 다르게 움직인다.
- 이게 반영되지 않는다면 바운디드 컨텍스트가 없는 통합 모델을 사용하고 있지 않는지 확인해라.
- 또한 이런 단계에서는 통합이 필요할 것이며, 컨텍스트들 사이의 매핑이 반드시 필요하단 걸 기억해라.

### 6. 구성 요소
- 가장 중요한 구성 요소는 역시나 모델이다.
- 하지만 모델 외에 다른 요소들도 바운디드 컨텍스트 안에 존재할 수 있다.
- 도메인 모델과의 상호작용과 이를 위해 존재하는 요소들은 바운디드 컨텍스트 안에 존재해야 된다.
- 도메인 모델과 관련된 UI, 서비스, 영속화 레이어는 같은 바운디드 컨텍스트 안에 존재해야 된다는 의미다.

### 7. 크기?
- 완전한 유비쿼터스 언어를 표현할만큼 충분히 커야 한다.
- 핵심 도메인 외 외부 개념은 절대 넣지 말아라. (범용 서브도메인에 넣거나 들어오지 못할 개념이 아닌지 확인해라)
- DDD가 아닌 임의의 규칙 때문에 바운디드 컨텍스트의 크기를 바꾸지 말아라.
- 기준점은 언제나 유비쿼터스 언어다. 아키텍처적 영향으로 나누지 말아라.
- 인프라가 기술적 경계로 바운디드 컨텍스트를 나누도록 두지 말아라.
- 개발 리소스로 바운디드 컨텍스트 나누지 말아라.
- 당연히 쉽지 않은 일이다. DDD 개념을 생각하며 신중하게 바운디드 컨텍스트를 정의해라. 너무 성급하게 최소화하지도 말라.

### 8. 기술적 컴포넌트
- 기술적 컴포넌트가 바운디드 컨텍스트를 정의해주진 않는다. 절대로.
- 다만 기술적 컴포넌트에 바운디드 컨텍스트를 반영시키는 건 괜찮은 생각일 수 있다.
- 자바의 경우 한 프로젝트당 하나의 바운디드 컨텍스트만 넣어라.
- 최상위 패키지와 바운디드 컨텍스트의 최상위 모듈 이름을 매핑하면 좋다.

## 컨텍스트 맵
### 방법?
- 둘 이상의 기존 바운디드 컨텍스트들 사이의 매핑을 보여주는 단순한 다이어그램을 그린다. (단순 반복이 될 확률 높음)
- 통합의 소스 코드 구현을 통해 컨텍스트 맵을 나타낸다. (이 방안 추천)

### 왜 써야 하나?
- 성공하기 위한 해결책 관점을 제공해준다.
- 상호 교류해야 하는 시스템의 목록을 제공한다.
- 팀내 의사소통의 촉매 역할을 수행한다.
- 작성 과정에서 모든 다른 의존 프로젝트들과의 관계, 위험성을 고려하게 만든다. (아주 중요...)
- 엔터프라이즈 아키텍처나 시스템 위상 다이어그램과는 전혀 다르다.
- 조직 역학을 보여줄 수 있다.

### 어떻게 그리나?
- 일단 현재 상태를 슥슥 그리자
- 현재 구현할 서비스와 관련 될 예정인 다른 서비스 그리면 되는 것 같다.
- 아무튼 자주 볼 수 있는 곳에 놔둬라
